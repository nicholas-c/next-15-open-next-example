"use strict";function _export(t,e){for(var n in e)Object.defineProperty(t,n,{enumerable:!0,get:e[n]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{JsConfigPathsPlugin:function(){return JsConfigPathsPlugin},findBestPatternMatch:function(){return findBestPatternMatch},hasZeroOrOneAsteriskCharacter:function(){return hasZeroOrOneAsteriskCharacter},isString:function(){return isString},matchPatternOrExact:function(){return matchPatternOrExact},matchedText:function(){return matchedText},pathIsRelative:function(){return pathIsRelative},patternText:function(){return patternText},tryParsePattern:function(){return tryParsePattern}});const _path=_interop_require_default(require("path")),_debug=require("next/dist/compiled/debug");function _interop_require_default(t){return t&&t.__esModule?t:{default:t}}const log=(0,_debug.debug)("next:jsconfig-paths-plugin"),asterisk=42;function hasZeroOrOneAsteriskCharacter(t){let e=!1;for(let n=0;n<t.length;n++)if(t.charCodeAt(n)===asterisk){if(e)return!1;e=!0}return!0}function pathIsRelative(t){return/^\.\.?($|[\\/])/.test(t)}function tryParsePattern(t){const e=t.indexOf("*");return-1===e?void 0:{prefix:t.slice(0,e),suffix:t.slice(e+1)}}function isPatternMatch({prefix:t,suffix:e},n){return n.length>=t.length+e.length&&n.startsWith(t)&&n.endsWith(e)}function findBestPatternMatch(t,e,n){let r,s=-1;for(const i of t){const t=e(i);isPatternMatch(t,n)&&t.prefix.length>s&&(s=t.prefix.length,r=i)}return r}function matchPatternOrExact(t,e){const n=[];for(const r of t){if(!hasZeroOrOneAsteriskCharacter(r))continue;const t=tryParsePattern(r);if(t)n.push(t);else if(r===e)return r}return findBestPatternMatch(n,(t=>t),e)}function isString(t){return"string"==typeof t}function matchedText(t,e){return e.substring(t.prefix.length,e.length-t.suffix.length)}function patternText({prefix:t,suffix:e}){return`${t}*${e}`}function forEachBail(t,e,n){if(0===t.length)return n();let r=0;const s=()=>{let i;return e(t[r++],((e,o)=>{if(e||void 0!==o||r>=t.length)return n(e,o);if(!1===i)for(;s(););i=!0})),i||(i=!1),i};for(;s(););}const NODE_MODULES_REGEX=/node_modules/;class JsConfigPathsPlugin{constructor(t,e){this.paths=t,this.resolvedBaseUrl=e,this.jsConfigPlugin=!0,log("tsconfig.json or jsconfig.json paths: %O",t),log("resolved baseUrl: %s",e)}apply(t){const e=t.ensureHook("resolve");t.getHook("described-resolve").tapAsync("JsConfigPathsPlugin",((n,r,s)=>{const i=this.resolvedBaseUrl;if(void 0===i)return s();const o=this.paths,a=Object.keys(o);if(0===a.length)return log("paths are empty, bailing out"),s();const u=n.request;if(n.path.match(NODE_MODULES_REGEX))return log("skipping request as it is inside node_modules %s",u),s();if(_path.default.posix.isAbsolute(u)||"win32"===process.platform&&_path.default.win32.isAbsolute(u))return log("skipping request as it is an absolute path %s",u),s();if(pathIsRelative(u))return log("skipping request as it is a relative path %s",u),s();const c=matchPatternOrExact(a,u);if(!c)return log("moduleName did not match any paths pattern %s",u),s();const f=isString(c)?void 0:matchedText(c,u),l=isString(c)?c:patternText(c);let h=[];forEachBail(o[l],((s,o)=>{const a=f?s.replace("*",f):s;if(a.endsWith(".d.ts"))return o();const u=_path.default.join(i.baseUrl,a),c=Object.assign({},n,{request:u});t.doResolve(e,c,`Aliased with tsconfig.json or jsconfig.json ${l} to ${u}`,r,((t,e)=>t||void 0===e?(h.push(u),o()):o(t,e)))}),s)}))}}