"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"NextTypesPlugin",{enumerable:!0,get:function(){return NextTypesPlugin}});const _promises=_interop_require_default(require("fs/promises")),_webpack=require("next/dist/compiled/webpack/webpack"),_pathtoregexp=require("next/dist/compiled/path-to-regexp"),_path=_interop_require_default(require("path")),_constants=require("../../../../lib/constants"),_denormalizepagepath=require("../../../../shared/lib/page-path/denormalize-page-path"),_ensureleadingslash=require("../../../../shared/lib/page-path/ensure-leading-slash"),_normalizepathsep=require("../../../../shared/lib/page-path/normalize-path-sep"),_http=require("../../../../server/web/http"),_utils=require("../../../../shared/lib/router/utils"),_apppaths=require("../../../../shared/lib/router/utils/app-paths"),_entries=require("../../../entries"),_shared=require("./shared"),_buildcontext=require("../../../build-context");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}const PLUGIN_NAME="NextTypesPlugin";function createTypeGuardFile(e,t,n){return`// File: ${e}\nimport * as entry from '${t}.js'\n${"route"===n.type?"import type { NextRequest } from 'next/server.js'":"import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'"}\n\ntype TEntry = typeof import('${t}.js')\n\ntype SegmentParams<T extends Object = any> = T extends Record<string, any>\n  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }\n  : T\n\n// Check that the entry is a valid entry\ncheckFields<Diff<{\n  ${"route"===n.type?_http.HTTP_METHODS.map((e=>`${e}?: Function`)).join("\n  "):"default: Function"}\n  config?: {}\n  generateStaticParams?: Function\n  revalidate?: RevalidateRange<TEntry> | false\n  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n  dynamicParams?: boolean\n  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'\n  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]\n  runtime?: 'nodejs' | 'experimental-edge' | 'edge'\n  maxDuration?: number\n  ${"route"===n.type?"":"\n  metadata?: any\n  generateMetadata?: Function\n  viewport?: any\n  generateViewport?: Function\n  experimental_ppr?: boolean\n  "}\n}, TEntry, ''>>()\n\n${"route"===n.type?"type RouteContext = { params: Promise<SegmentParams> }":""}\n${"route"===n.type?_http.HTTP_METHODS.map((e=>`// Check the prop type of the entry function\nif ('${e}' in entry) {\n  checkFields<\n    Diff<\n      ParamCheck<Request | NextRequest>,\n      {\n        __tag__: '${e}'\n        __param_position__: 'first'\n        __param_type__: FirstArg<MaybeField<TEntry, '${e}'>>\n      },\n      '${e}'\n    >\n  >()\n  checkFields<\n    Diff<\n      ParamCheck<RouteContext>,\n      {\n        __tag__: '${e}'\n        __param_position__: 'second'\n        __param_type__: SecondArg<MaybeField<TEntry, '${e}'>>\n      },\n      '${e}'\n    >\n  >()\n  \n  checkFields<\n    Diff<\n      {\n        __tag__: '${e}',\n        __return_type__: Response | void | never | Promise<Response | void | never>\n      },\n      {\n        __tag__: '${e}',\n        __return_type__: ReturnType<MaybeField<TEntry, '${e}'>>\n      },\n      '${e}'\n    >\n  >()\n}\n`)).join(""):`// Check the prop type of the entry function\ncheckFields<Diff<${"page"===n.type?"PageProps":"LayoutProps"}, FirstArg<TEntry['default']>, 'default'>>()\n\n// Check the arguments and return type of the generateMetadata function\nif ('generateMetadata' in entry) {\n  checkFields<Diff<${"page"===n.type?"PageProps":"LayoutProps"}, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n}\n\n// Check the arguments and return type of the generateViewport function\nif ('generateViewport' in entry) {\n  checkFields<Diff<${"page"===n.type?"PageProps":"LayoutProps"}, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()\n  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()\n}\n`}\n// Check the arguments and return type of the generateStaticParams function\nif ('generateStaticParams' in entry) {\n  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()\n  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()\n}\n\nexport interface PageProps {\n  params?: Promise<SegmentParams>\n  searchParams?: Promise<any>\n}\nexport interface LayoutProps {\n  children?: React.ReactNode\n${n.slots?n.slots.map((e=>`  ${e}: React.ReactNode`)).join("\n"):""}\n  params?: Promise<SegmentParams>\n}\n\n// =============\n// Utility types\ntype RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never\n\n// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.\ntype OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>\ntype Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>\n\ntype FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never\ntype SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never\ntype MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never\n\n${"route"===n.type?"type ParamCheck<T> = {\n  __tag__: string\n  __param_position__: string\n  __param_type__: T\n}":""}\n\nfunction checkFields<_ extends { [k in keyof any]: never }>() {}\n\n// https://github.com/sindresorhus/type-fest\ntype Numeric = number | bigint\ntype Zero = 0 | 0n\ntype Negative<T extends Numeric> = T extends Zero ? never : \`\${T}\` extends \`-\${string}\` ? T : never\ntype NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'\n`}async function collectNamedSlots(e){const t=_path.default.dirname(e),n=await _promises.default.readdir(t,{withFileTypes:!0}),r=[];for(const e of n)e.isDirectory()&&e.name.startsWith("@")&&"@children"!==e.name&&r.push(e.name.slice(1));return r}const pluginState=(0,_buildcontext.getProxiedPluginState)({collectedRootParams:{},routeTypes:{edge:{static:"",dynamic:""},node:{static:"",dynamic:""},extra:{static:"",dynamic:""}}});function formatRouteToRouteType(e){const t=(0,_utils.isDynamicRoute)(e);return t&&(e=e.split("/").map((e=>e.startsWith("[")&&e.endsWith("]")?e.startsWith("[...")?"${CatchAllSlug<T>}":e.startsWith("[[...")&&e.endsWith("]]")?"${OptionalCatchAllSlug<T>}":"${SafeSlug<T>}":e)).join("/")),{isDynamic:t,routeType:`\n    | \`${e}\``}}let redirectsRewritesTypesProcessed=!1;function addRedirectsRewritesRouteTypes(e,t){function n(e){let t;try{t=(0,_pathtoregexp.parse)(e)}catch{}if(Array.isArray(t)){const n=[""];let r=1;function s(e){for(let t=0;t<n.length;t++)n[t]+=e}function i(e){const t=n.length;for(let r=0;r<t;r++)n.push(n[r]+e)}for(const a of t)if("object"==typeof a){const o=a.name||(1==r++?"slug":`slug${r}`);if("*"===a.modifier)s(`${a.prefix}[[...${o}]]`);else if("+"===a.modifier)s(`${a.prefix}[...${o}]`);else if(""===a.modifier)if("[^\\/#\\?]+?"===a.pattern)s(`${a.prefix}[${o}]`);else if(".*"===a.pattern)s(`${a.prefix}[[...${o}]]`);else{if(".+"!==a.pattern)return;s(`${a.prefix}[...${o}]`)}else if("?"===a.modifier){if(!/^[a-zA-Z0-9_/]*$/.test(a.pattern))return;s(a.prefix),i(a.pattern)}}else"string"==typeof a&&s(a);for(const p of n){const{isDynamic:c,routeType:u}=formatRouteToRouteType(p);pluginState.routeTypes.extra[c?"dynamic":"static"]+=u}}}if(e){for(const t of e.beforeFiles)n(t.source);for(const t of e.afterFiles)n(t.source);for(const t of e.fallback)n(t.source)}if(t)for(const e of t)"internal"in e||n(e.source)}function createRouteDefinitions(){let e="",t="";for(const n of["edge","node","extra"])e+=pluginState.routeTypes[n].static,t+=pluginState.routeTypes[n].dynamic;return`// Type definitions for Next.js routes\n\n/**\n * Internal types used by the Next.js router and Link component.\n * These types are not meant to be used directly.\n * @internal\n */\ndeclare namespace __next_route_internal_types__ {\n  type SearchOrHash = \`?\${string}\` | \`#\${string}\`\n  type WithProtocol = \`\${string}:\${string}\`\n\n  type Suffix = '' | SearchOrHash\n\n  type SafeSlug<S extends string> = S extends \`\${string}/\${string}\`\n    ? never\n    : S extends \`\${string}\${SearchOrHash}\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type CatchAllSlug<S extends string> = S extends \`\${string}\${SearchOrHash}\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type OptionalCatchAllSlug<S extends string> =\n    S extends \`\${string}\${SearchOrHash}\` ? never : S\n\n  type StaticRoutes = ${e||"never"}\n  type DynamicRoutes<T extends string = string> = ${t||"never"}\n\n  type RouteImpl<T> = ${(e||t?"":"string & {}")||"\n    | StaticRoutes\n    | SearchOrHash\n    | WithProtocol\n    | `${StaticRoutes}${SearchOrHash}`\n    | (T extends `${DynamicRoutes<infer _>}${Suffix}` ? T : never)\n    "}\n}\n\ndeclare module 'next' {\n  export { default } from 'next/types.js'\n  export * from 'next/types.js'\n\n  export type Route<T extends string = string> =\n    __next_route_internal_types__.RouteImpl<T>\n}\n\ndeclare module 'next/link' {\n  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'\n  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'\n  import type { UrlObject } from 'url'\n\n  type LinkRestProps = Omit<\n    Omit<\n      DetailedHTMLProps<\n        AnchorHTMLAttributes<HTMLAnchorElement>,\n        HTMLAnchorElement\n      >,\n      keyof OriginalLinkProps\n    > &\n      OriginalLinkProps,\n    'href'\n  >\n\n  export type LinkProps<RouteInferType> = LinkRestProps & {\n    /**\n     * The path or URL to navigate to. This is the only required prop. It can also be an object.\n     * @see https://nextjs.org/docs/api-reference/next/link\n     */\n    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject\n  }\n\n  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element\n}\n\ndeclare module 'next/navigation' {\n  export * from 'next/dist/client/components/navigation.js'\n\n  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'\n  interface AppRouterInstance extends OriginalAppRouterInstance {\n    /**\n     * Navigate to the provided href.\n     * Pushes a new history entry.\n     */\n    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Navigate to the provided href.\n     * Replaces the current history entry.\n     */\n    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Prefetch the provided href.\n     */\n    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void\n  }\n\n  export function useRouter(): AppRouterInstance;\n}\n\ndeclare module 'next/form' {\n  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'\n\n  type FormRestProps = Omit<OriginalFormProps, 'action'>\n\n  export type FormProps<RouteInferType> = {\n    /**\n     * \`action\` can be either a \`string\` or a function.\n     * - If \`action\` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n     *   The path will be prefetched when the form becomes visible.\n     * - If \`action\` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n     */\n    action: __next_route_internal_types__.RouteImpl<RouteInferType> | ((formData: FormData) => void)\n  } & FormRestProps\n\n  export default function Form<RouteType>(props: FormProps<RouteType>): JSX.Element\n}\n`}function formatTimespan(e){if(e>0){if(18748800===e)return"1 month";if(18144e3===e)return"1 month";if(604800===e)return"1 week";if(86400===e)return"1 day";if(3600===e)return"1 hour";if(60===e)return"1 minute";if(e%18748800==0)return e/18748800+" months";if(e%18144e3==0)return e/18144e3+" months";if(e%604800==0)return e/604800+" weeks";if(e%86400==0)return e/86400+" days";if(e%3600==0)return e/3600+" hours";if(e%60==0)return e/60+" minutes"}return e+" seconds"}function formatTimespanWithSeconds(e){if(void 0===e)return"default";if(e>=4294967294)return"never";const t=e+" seconds",n=formatTimespan(e);return n===t?t:t+" ("+n+")"}function getRootParamsFromLayouts(e){const t=Object.entries(e).sort(((e,t)=>t[0].split("/").length-e[0].split("/").length));if(!t.length)return[];let n=t[t.length-1][0],r=new Set,s=!1;for(const[e,i]of t){if(e.split("/").slice(1,-1).every((e=>/^\[[^[.\]]+\]$/.test(e))))if(isSubpath(n,e))n=e,r=new Set(i);else{s=!0;for(const e of i)r.add(e)}}return Array.from(r).map((e=>({param:e,optional:s})))}function isSubpath(e,t){const n=e.split("/").slice(1,-1),r=t.split("/").slice(1,-1);return!(r.length>n.length||!r.length)&&r.every(((e,t)=>e===n[t]))}function createServerDefinitions(e){return`\n  declare module 'next/server' {\n\n    import type { AsyncLocalStorage as NodeAsyncLocalStorage } from 'async_hooks'\n    declare global {\n      var AsyncLocalStorage: typeof NodeAsyncLocalStorage\n    }\n    export { NextFetchEvent } from 'next/dist/server/web/spec-extension/fetch-event'\n    export { NextRequest } from 'next/dist/server/web/spec-extension/request'\n    export { NextResponse } from 'next/dist/server/web/spec-extension/response'\n    export { NextMiddleware, MiddlewareConfig } from 'next/dist/server/web/types'\n    export { userAgentFromString } from 'next/dist/server/web/spec-extension/user-agent'\n    export { userAgent } from 'next/dist/server/web/spec-extension/user-agent'\n    export { URLPattern } from 'next/dist/compiled/@edge-runtime/primitives/url'\n    export { ImageResponse } from 'next/dist/server/web/spec-extension/image-response'\n    export type { ImageResponseOptions } from 'next/dist/compiled/@vercel/og/types'\n    export { after } from 'next/dist/server/after'\n    export { connection } from 'next/dist/server/request/connection'\n    export type { UnsafeUnwrappedSearchParams } from 'next/dist/server/request/search-params'\n    export type { UnsafeUnwrappedParams } from 'next/dist/server/request/params'\n    export function unstable_rootParams(): Promise<{ ${e.map((({param:e,optional:t})=>`${e.includes("-")?`'${e}'`:e}${t?"?":""}: string`)).join(", ")} }>\n  }\n  `}function createCustomCacheLifeDefinitions(e){let t="";const n=Object.keys(e);for(let r=0;r<n.length;r++){const s=n[r],i=e[s];if("object"!=typeof i||null===i)continue;let a="";void 0===i.stale?a+="\n     * This cache may be stale on clients for the default stale time of the scope before checking with the server.":i.stale>=4294967294?a+="\n     * This cache may be stale on clients indefinitely before checking with the server.":a+=`\n     * This cache may be stale on clients for ${formatTimespan(i.stale)} before checking with the server.`,void 0!==i.revalidate&&void 0!==i.expire&&i.revalidate>=i.expire?a+=`\n     * This cache will expire after ${formatTimespan(i.expire)}. The next request will recompute it.`:(void 0===i.revalidate?a+="\n     * It will inherit the default revalidate time of its scope since it does not define its own.":i.revalidate>=4294967294||(a+=`\n     * If the server receives a new request after ${formatTimespan(i.revalidate)}, start revalidating new values in the background.`),void 0===i.expire?a+="\n     * It will inherit the default expiration time of its scope since it does not define its own.":i.expire>=4294967294?a+="\n     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.":a+=`\n     * If this entry has no traffic for ${formatTimespan(i.expire)} it will expire. The next request will recompute it.`),t+=`\n    /**\n     * Cache this \`"use cache"\` for a timespan defined by the \`${JSON.stringify(s)}\` profile.\n     * \`\`\`\n     *   stale:      ${formatTimespanWithSeconds(i.stale)}\n     *   revalidate: ${formatTimespanWithSeconds(i.revalidate)}\n     *   expire:     ${formatTimespanWithSeconds(i.expire)}\n     * \`\`\`\n     * ${a}\n     */\n    export function unstable_cacheLife(profile: ${JSON.stringify(s)}): void\n    `}return t+='\n    /**\n     * Cache this `"use cache"` using a custom timespan.\n     * ```\n     *   stale: ... // seconds\n     *   revalidate: ... // seconds\n     *   expire: ... // seconds\n     * ```\n     *\n     * This is similar to Cache-Control: max-age=`stale`,s-max-age=`revalidate`,stale-while-revalidate=`expire-revalidate`\n     *\n     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n     */\n    export function unstable_cacheLife(profile: {\n      /**\n       * This cache may be stale on clients for ... seconds before checking with the server.\n       */\n      stale?: number,\n      /**\n       * If the server receives a new request after ... seconds, start revalidating new values in the background.\n       */\n      revalidate?: number,\n      /**\n       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n       */\n      expire?: number\n    }): void\n  ',`// Type definitions for Next.js cacheLife configs\n\ndeclare module 'next/cache' {\n  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n  export {\n    revalidateTag,\n    revalidatePath,\n    unstable_expireTag,\n    unstable_expirePath,\n  } from 'next/dist/server/web/spec-extension/revalidate'\n  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n\n  ${t}\n\n  export { cacheTag as unstable_cacheTag } from 'next/dist/server/use-cache/cache-tag'\n}\n`}const appTypesBasePath=_path.default.join("types","app");class NextTypesPlugin{constructor(e){this.dir=e.dir,this.distDir=e.distDir,this.appDir=e.appDir,this.dev=e.dev,this.isEdgeServer=e.isEdgeServer,this.pageExtensions=e.pageExtensions,this.pagesDir=_path.default.join(this.appDir,"..","pages"),this.typedRoutes=e.typedRoutes,this.cacheLifeConfig=e.cacheLifeConfig,this.distDirAbsolutePath=_path.default.join(this.dir,this.distDir),this.typedRoutes&&!redirectsRewritesTypesProcessed&&(redirectsRewritesTypesProcessed=!0,addRedirectsRewritesRouteTypes(e.originalRewrites,e.originalRedirects))}getRelativePathFromAppTypesDir(e){const t=_path.default.join(this.appDir,e),n=_path.default.join(this.distDirAbsolutePath,appTypesBasePath,e);return _path.default.relative(n+"/..",t)}collectPage(e){if(!this.typedRoutes)return;const t=e.startsWith(this.appDir+_path.default.sep),n=!t&&e.startsWith(this.pagesDir+_path.default.sep);if(!t&&!n)return;if(t&&!/[/\\](?:page|route)\.[^.]+$/.test(e))return;if(n&&/[/\\](?:_app|_document|_error|404|500)\.[^.]+$/.test(e))return;let r=(t?_apppaths.normalizeAppPath:_denormalizepagepath.denormalizePagePath)((0,_ensureleadingslash.ensureLeadingSlash)((0,_entries.getPageFromPath)(_path.default.relative(t?this.appDir:this.pagesDir,e),this.pageExtensions)));const{isDynamic:s,routeType:i}=formatRouteToRouteType(r);pluginState.routeTypes[this.isEdgeServer?"edge":"node"][s?"dynamic":"static"]+=i}apply(e){const t=this.dev||this.isEdgeServer?"..":"../..",n=async(e,n)=>{if(!e.resource)return;const r=new RegExp(`\\.(${this.pageExtensions.join("|")})$`);if(!r.test(e.resource))return;if(!e.resource.startsWith(this.appDir+_path.default.sep))return void(this.dev||e.resource.startsWith(this.pagesDir+_path.default.sep)&&this.collectPage(e.resource));if(e.layer!==_constants.WEBPACK_LAYERS.reactServerComponents)return;if(/(?:\/[^/]+)*\/_.*$/.test(e.resource.replace(this.appDir,"")))return;const s=/[/\\]layout\.[^./\\]+$/.test(e.resource),i=!s&&/[/\\]page\.[^.]+$/.test(e.resource),a=!i&&/[/\\]route\.[^.]+$/.test(e.resource),o=/\.(js|jsx|ts|tsx|mjs|cjs)$/.test(e.resource),p=_path.default.relative(this.appDir,e.resource);this.dev||(i||a)&&this.collectPage(e.resource);const c=_path.default.join(appTypesBasePath,p.replace(r,".ts")),u=(0,_normalizepathsep.normalizePathSep)(_path.default.join(this.getRelativePathFromAppTypesDir(p)).replace(r,"")),l=_path.default.join(t,c);if(o)if(s){const t=(0,_apppaths.normalizeAppPath)((0,_ensureleadingslash.ensureLeadingSlash)((0,_entries.getPageFromPath)(_path.default.relative(this.appDir,e.resource),this.pageExtensions))),r=Array.from(t.matchAll(/\[(.*?)\]/g),(e=>e[1]));pluginState.collectedRootParams[t]=r;const s=await collectNamedSlots(e.resource);n.emitAsset(l,new _webpack.sources.RawSource(createTypeGuardFile(e.resource,u,{type:"layout",slots:s})))}else i?n.emitAsset(l,new _webpack.sources.RawSource(createTypeGuardFile(e.resource,u,{type:"page"}))):a&&n.emitAsset(l,new _webpack.sources.RawSource(createTypeGuardFile(e.resource,u,{type:"route"})))};e.hooks.compilation.tap(PLUGIN_NAME,(e=>{e.hooks.processAssets.tapAsync({name:PLUGIN_NAME,stage:_webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH},(async(r,s)=>{const i=[];this.isEdgeServer?(pluginState.routeTypes.edge.dynamic="",pluginState.routeTypes.edge.static=""):(pluginState.routeTypes.node.dynamic="",pluginState.routeTypes.node.static=""),e.chunkGroups.forEach((t=>{t.chunks.forEach((t=>{if(!t.name)return;if(!(t.name.startsWith("pages/")||t.name.startsWith("app/")&&(t.name.endsWith("/page")||t.name.endsWith("/route"))))return;const r=e.chunkGraph.getChunkModulesIterable(t);for(const t of r){i.push(n(t,e));const r=t;r.modules&&r.modules.forEach((t=>{i.push(n(t,e))}))}}))})),await Promise.all(i);const a=getRootParamsFromLayouts(pluginState.collectedRootParams);if(a.length>0){const n=_path.default.join(t,"types/server.d.ts");e.emitAsset(n,new _webpack.sources.RawSource(createServerDefinitions(a)))}const o=_path.default.join(t,"types/package.json");if(e.emitAsset(o,new _webpack.sources.RawSource('{"type": "module"}')),this.typedRoutes){this.dev&&!this.isEdgeServer&&_shared.devPageFiles.forEach((e=>{this.collectPage(e)}));const n=_path.default.join(t,"types/link.d.ts");e.emitAsset(n,new _webpack.sources.RawSource(createRouteDefinitions()))}if(this.cacheLifeConfig){const n=_path.default.join(t,"types/cache-life.d.ts");e.emitAsset(n,new _webpack.sources.RawSource(createCustomCacheLifeDefinitions(this.cacheLifeConfig)))}s()}))}))}}