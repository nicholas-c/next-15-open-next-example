"use strict";function _export(e,r){for(var t in r)Object.defineProperty(e,t,{enumerable:!0,get:r[t]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{NoSuchDeclarationError:function(){return NoSuchDeclarationError},UnsupportedValueError:function(){return UnsupportedValueError},extractExportedConstValue:function(){return extractExportedConstValue}});class NoSuchDeclarationError extends Error{}function isExportDeclaration(e){return"ExportDeclaration"===e.type}function isVariableDeclaration(e){return"VariableDeclaration"===e.type}function isIdentifier(e){return"Identifier"===e.type}function isBooleanLiteral(e){return"BooleanLiteral"===e.type}function isNullLiteral(e){return"NullLiteral"===e.type}function isStringLiteral(e){return"StringLiteral"===e.type}function isNumericLiteral(e){return"NumericLiteral"===e.type}function isArrayExpression(e){return"ArrayExpression"===e.type}function isObjectExpression(e){return"ObjectExpression"===e.type}function isKeyValueProperty(e){return"KeyValueProperty"===e.type}function isRegExpLiteral(e){return"RegExpLiteral"===e.type}function isTemplateLiteral(e){return"TemplateLiteral"===e.type}function isTsSatisfiesExpression(e){return"TsSatisfiesExpression"===e.type}class UnsupportedValueError extends Error{constructor(e,r){let t;if(super(e),r){t="";for(const e of r)"["===e[0]?t+=e:""===t?t=e:t+=`.${e}`}this.path=t}}function extractValue(e,r){if(isNullLiteral(e))return null;if(isBooleanLiteral(e))return e.value;if(isStringLiteral(e))return e.value;if(isNumericLiteral(e))return e.value;if(isRegExpLiteral(e))return new RegExp(e.pattern,e.flags);if(isIdentifier(e)){if("undefined"===e.value)return;throw new UnsupportedValueError(`Unknown identifier "${e.value}"`,r)}if(isArrayExpression(e)){const t=[];for(let n=0,i=e.elements.length;n<i;n++){const i=e.elements[n];if(i){if(i.spread)throw new UnsupportedValueError("Unsupported spread operator in the Array Expression",r);t.push(extractValue(i.expression,r&&[...r,`[${n}]`]))}else t.push(void 0)}return t}if(isObjectExpression(e)){const t={};for(const n of e.properties){if(!isKeyValueProperty(n))throw new UnsupportedValueError("Unsupported spread operator in the Object Expression",r);let e;if(isIdentifier(n.key))e=n.key.value;else{if(!isStringLiteral(n.key))throw new UnsupportedValueError(`Unsupported key type "${n.key.type}" in the Object Expression`,r);e=n.key.value}t[e]=extractValue(n.value,r&&[...r,e])}return t}if(isTemplateLiteral(e)){if(0!==e.expressions.length)throw new UnsupportedValueError("Unsupported template literal with expressions",r);const[{cooked:t,raw:n}]=e.quasis;return t??n}if(isTsSatisfiesExpression(e))return extractValue(e.expression);throw new UnsupportedValueError(`Unsupported node type "${e.type}"`,r)}function extractExportedConstValue(e,r){for(const t of e.body){if(!isExportDeclaration(t))continue;const e=t.declaration;if(isVariableDeclaration(e)&&"const"===e.kind)for(const t of e.declarations)if(isIdentifier(t.id)&&t.id.value===r&&t.init)return extractValue(t.init,[r])}throw new NoSuchDeclarationError}