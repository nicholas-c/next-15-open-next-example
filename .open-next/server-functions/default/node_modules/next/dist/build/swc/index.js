"use strict";function _export(e,r){for(var t in r)Object.defineProperty(e,t,{enumerable:!0,get:r[t]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{createDefineEnv:function(){return createDefineEnv},getBinaryMetadata:function(){return getBinaryMetadata},getSupportedArchTriples:function(){return getSupportedArchTriples},initCustomTraceSubscriber:function(){return initCustomTraceSubscriber},isWasm:function(){return isWasm},loadBindings:function(){return loadBindings},lockfilePatchPromise:function(){return lockfilePatchPromise},minify:function(){return minify},parse:function(){return parse},teardownTraceSubscriber:function(){return teardownTraceSubscriber},transform:function(){return transform},transformSync:function(){return transformSync}});const _path=_interop_require_default(require("path")),_url=require("url"),_os=require("os"),_triples=require("next/dist/compiled/@napi-rs/triples"),_log=_interop_require_wildcard(require("../output/log")),_options=require("./options"),_swcloadfailure=require("../../telemetry/events/swc-load-failure"),_patchincorrectlockfile=require("../../lib/patch-incorrect-lockfile"),_downloadswc=require("../../lib/download-swc"),_util=require("util"),_defineenvplugin=require("../webpack/plugins/define-env-plugin"),_getbabelloaderconfig=require("../get-babel-loader-config"),_utils=require("../../shared/lib/turbopack/utils");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interop_require_wildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var a=i?Object.getOwnPropertyDescriptor(e,o):null;a&&(a.get||a.set)?Object.defineProperty(n,o,a):n[o]=e[o]}return n.default=e,t&&t.set(e,n),n}const nextVersion="15.2.0",ArchName=(0,_os.arch)(),PlatformName=(0,_os.platform)();function infoLog(...e){process.env.NEXT_PRIVATE_BUILD_WORKER||process.env.DEBUG&&_log.info(...e)}function getSupportedArchTriples(){const{darwin:e,win32:r,linux:t,freebsd:n,android:i}=_triples.platformArchTriples;return{darwin:e,win32:{arm64:r.arm64,ia32:r.ia32.filter((e=>"msvc"===e.abi)),x64:r.x64.filter((e=>"msvc"===e.abi))},linux:{x64:t.x64.filter((e=>"gnux32"!==e.abi)),arm64:t.arm64,arm:t.arm},freebsd:{x64:n.x64},android:{arm64:i.arm64,arm:i.arm}}}const triples=(()=>{var e,r;const t=null==(e=getSupportedArchTriples()[PlatformName])?void 0:e[ArchName];if(t)return t;let n=null==(r=_triples.platformArchTriples[PlatformName])?void 0:r[ArchName];return n?_log.warn(`Trying to load next-swc for target triple ${n}, but there next-swc does not have native bindings support`):_log.warn(`Trying to load next-swc for unsupported platforms ${PlatformName}/${ArchName}`),[]})(),__INTERNAL_CUSTOM_TURBOPACK_BINDINGS=process.env.__INTERNAL_CUSTOM_TURBOPACK_BINDINGS;function checkVersionMismatch(e){const r=e.version;r&&r!==nextVersion&&_log.warn(`Mismatching @next/swc version, detected: ${r} while Next.js is on ${nextVersion}. Please ensure these match`)}const knownDefaultWasmFallbackTriples=["x86_64-unknown-freebsd","aarch64-linux-android","arm-linux-androideabi","armv7-unknown-linux-gnueabihf","i686-pc-windows-msvc"];let lastNativeBindingsLoadErrorCode,nativeBindings,wasmBindings,downloadWasmPromise,pendingBindings,swcTraceFlushGuard,downloadNativeBindingsPromise;const lockfilePatchPromise={};async function loadBindings(e=!1){return process.env.RUST_MIN_STACK||(process.env.RUST_MIN_STACK="8388608"),pendingBindings||(null!=process.stdout._handle&&(null==process.stdout._handle.setBlocking||process.stdout._handle.setBlocking.call(process.stdout._handle,!0)),null!=process.stderr._handle&&(null==process.stderr._handle.setBlocking||process.stderr._handle.setBlocking.call(process.stderr._handle,!0)),pendingBindings=new Promise((async(r,t)=>{lockfilePatchPromise.cur||(lockfilePatchPromise.cur=(0,_patchincorrectlockfile.patchIncorrectLockfile)(process.cwd()).catch(console.error));let n=[];const i=process.env.NEXT_DISABLE_SWC_WASM,o=triples.some((e=>!!(null==e?void 0:e.raw)&&knownDefaultWasmFallbackTriples.includes(e.raw))),a=process.versions.webcontainer,s=!i&&e||o||a;if(!o&&e&&_log.warn(`experimental.useWasmBinary is not an option for supported platform ${PlatformName}/${ArchName} and will be ignored.`),s){lastNativeBindingsLoadErrorCode="unsupported_target";const e=await tryLoadWasmWithFallback(n);if(e)return r(e)}try{return r(loadNative())}catch(e){if(Array.isArray(e)&&e.every((e=>e.includes("it was not installed")))){let e=await tryLoadNativeWithFallback(n);if(e)return r(e)}n=n.concat(e)}if(!s&&!i){const e=await tryLoadWasmWithFallback(n);if(e)return r(e)}logLoadFailure(n,!0)})),pendingBindings)}async function tryLoadNativeWithFallback(e){const r=_path.default.join(_path.default.dirname(require.resolve("next/package.json")),"next-swc-fallback");downloadNativeBindingsPromise||(downloadNativeBindingsPromise=(0,_downloadswc.downloadNativeNextSwc)(nextVersion,r,triples.map((e=>e.platformArchABI)))),await downloadNativeBindingsPromise;try{return loadNative(r)}catch(r){e.push(...[].concat(r))}}async function tryLoadWasmWithFallback(e){try{let e=await loadWasm("");return(0,_swcloadfailure.eventSwcLoadFailure)({wasm:"enabled",nativeBindingsErrorCode:lastNativeBindingsLoadErrorCode}),e}catch(r){e.push(...[].concat(r))}try{const r=_path.default.join(_path.default.dirname(require.resolve("next/package.json")),"wasm");downloadWasmPromise||(downloadWasmPromise=(0,_downloadswc.downloadWasmSwc)(nextVersion,r)),await downloadWasmPromise;let t=await loadWasm(r);(0,_swcloadfailure.eventSwcLoadFailure)({wasm:"fallback",nativeBindingsErrorCode:lastNativeBindingsLoadErrorCode});for(const r of e)_log.warn(r);return t}catch(r){e.push(...[].concat(r))}}function loadBindingsSync(){let e=[];try{return loadNative()}catch(r){e=e.concat(r)}if(wasmBindings)return wasmBindings;throw logLoadFailure(e),Object.defineProperty(new Error("Failed to load bindings",{cause:e}),"__NEXT_ERROR_CODE",{value:"E424",enumerable:!1,configurable:!0})}let loggingLoadFailure=!1;function logLoadFailure(e,r=!1){if(!loggingLoadFailure){loggingLoadFailure=!0;for(let r of e)_log.warn(r);(0,_swcloadfailure.eventSwcLoadFailure)({wasm:r?"failed":void 0,nativeBindingsErrorCode:lastNativeBindingsLoadErrorCode}).then((()=>lockfilePatchPromise.cur||Promise.resolve())).finally((()=>{_log.error(`Failed to load SWC binary for ${PlatformName}/${ArchName}, see more info here: https://nextjs.org/docs/messages/failed-loading-swc`),process.exit(1)}))}}function createDefineEnv({isTurbopack:e,clientRouterFilters:r,config:t,dev:n,distDir:i,fetchCacheKeyPrefix:o,hasRewrites:a,middlewareMatchers:s}){let c={client:[],edge:[],nodejs:[]};for(const l of Object.keys(c))c[l]=rustifyEnv((0,_defineenvplugin.getDefineEnv)({isTurbopack:e,clientRouterFilters:r,config:t,dev:n,distDir:i,fetchCacheKeyPrefix:o,hasRewrites:a,isClient:"client"===l,isEdgeServer:"edge"===l,isNodeOrEdgeCompilation:"nodejs"===l||"edge"===l,isNodeServer:"nodejs"===l,middlewareMatchers:s}));return c}function rustifyEnv(e){return Object.entries(e).filter((([e,r])=>null!=r)).map((([e,r])=>({name:e,value:r})))}function bindingToApi(e,r){const t=new class extends Error{};function n(e,r){throw Object.defineProperty(new Error(`Invariant: ${r(e)}`),"__NEXT_ERROR_CODE",{value:"E193",enumerable:!1,configurable:!0})}async function i(e){try{return await e()}catch(e){throw new _utils.TurbopackInternalError(e)}}function o(r,n){let o,a=[],s=!1;function c(e,t){if(o){let{resolve:r,reject:n}=o;o=void 0,e?n(e):r(t)}else{const n={err:e,value:t};r?a.push(n):a[0]=n}}async function*l(){const r=await i((()=>n(c)));try{for(;!s;)if(a.length>0){const e=a.shift();if(e.err)throw e.err;yield e.value}else yield new Promise(((e,r)=>{o={resolve:e,reject:r}}))}catch(e){if(e===t)return;if(e instanceof Error)throw new _utils.TurbopackInternalError(e);throw e}finally{r&&e.rootTaskDispose(r)}}const u=l();return u.return=async()=>(s=!0,o&&o.reject(t),{value:void 0,done:!0}),u}async function a(e){return{...e,nextConfig:await d(e.nextConfig,e.projectPath),jsConfig:JSON.stringify(e.jsConfig),env:rustifyEnv(e.env)}}async function s(e){return{...e,nextConfig:e.nextConfig&&await d(e.nextConfig,e.projectPath),jsConfig:e.jsConfig&&JSON.stringify(e.jsConfig),env:e.env&&rustifyEnv(e.env)}}class c{constructor(e){this._nativeProject=e}async update(r){await i((async()=>e.projectUpdate(this._nativeProject,await s(r))))}entrypointsSubscribe(){const r=o(!1,(async r=>e.projectEntrypointsSubscribe(this._nativeProject,r)));return async function*(){for await(const e of r){const r=new Map;for(const{pathname:t,...i}of e.routes){let e;const o=i.type;switch(o){case"page":e={type:"page",htmlEndpoint:new l(i.htmlEndpoint),dataEndpoint:new l(i.dataEndpoint)};break;case"page-api":e={type:"page-api",endpoint:new l(i.endpoint)};break;case"app-page":e={type:"app-page",pages:i.pages.map((e=>({originalName:e.originalName,htmlEndpoint:new l(e.htmlEndpoint),rscEndpoint:new l(e.rscEndpoint)})))};break;case"app-route":e={type:"app-route",originalName:i.originalName,endpoint:new l(i.endpoint)};break;case"conflict":e={type:"conflict"};break;default:const r=o;n(i,(()=>`Unknown route type: ${r}`))}r.set(t,e)}const t=e=>({endpoint:new l(e.endpoint),runtime:e.runtime,matcher:e.matcher}),i=e.middleware?t(e.middleware):void 0,o=e=>({nodeJs:new l(e.nodeJs),edge:new l(e.edge)}),a=e.instrumentation?o(e.instrumentation):void 0;yield{routes:r,middleware:i,instrumentation:a,pagesDocumentEndpoint:new l(e.pagesDocumentEndpoint),pagesAppEndpoint:new l(e.pagesAppEndpoint),pagesErrorEndpoint:new l(e.pagesErrorEndpoint),issues:e.issues,diagnostics:e.diagnostics}}}()}hmrEvents(r){return o(!0,(async t=>e.projectHmrEvents(this._nativeProject,r,t)))}hmrIdentifiersSubscribe(){return o(!1,(async r=>e.projectHmrIdentifiersSubscribe(this._nativeProject,r)))}traceSource(r,t){return e.projectTraceSource(this._nativeProject,r,t)}getSourceForAsset(r){return e.projectGetSourceForAsset(this._nativeProject,r)}getSourceMap(r){return e.projectGetSourceMap(this._nativeProject,r)}getSourceMapSync(r){return e.projectGetSourceMapSync(this._nativeProject,r)}updateInfoSubscribe(r){return o(!0,(async t=>e.projectUpdateInfoSubscribe(this._nativeProject,r,t)))}shutdown(){return e.projectShutdown(this._nativeProject)}onExit(){return e.projectOnExit(this._nativeProject)}}class l{constructor(e){this._nativeEndpoint=e}async writeToDisk(){return await i((()=>e.endpointWriteToDisk(this._nativeEndpoint)))}async clientChanged(){const r=o(!1,(async r=>e.endpointClientChangedSubscribe(await this._nativeEndpoint,r)));return await r.next(),r}async serverChanged(r){const t=o(!1,(async t=>e.endpointServerChangedSubscribe(await this._nativeEndpoint,r,t)));return await t.next(),t}}function u(e,r){var t;let n={...e};if(null==(t=n.experimental)?void 0:t.reactCompiler){var i,o;const t=["*.ts","*.js","*.jsx","*.tsx"];if(Object.keys((null==n||null==(o=n.experimental)||null==(i=o.turbo)?void 0:i.rules)??[]).some((e=>t.includes(e))))_log.warn("The React Compiler cannot be enabled automatically because 'experimental.turbo' contains a rule for '*.ts', '*.js', '*.jsx', and '*.tsx'. Remove this rule, or add 'babel-loader' and 'babel-plugin-react-compiler' to the Turbopack configuration manually.");else{n.experimental.turbo||(n.experimental.turbo={}),n.experimental.turbo.rules||(n.experimental.turbo.rules={});for(const t of["*.ts","*.js","*.jsx","*.tsx"])n.experimental.turbo.rules[t]={browser:{foreign:!1,loaders:[(0,_getbabelloaderconfig.getReactCompilerLoader)(e.experimental.reactCompiler,r,n.dev,!1,void 0)]}}}}return n}async function d(e,r){var t,n;let i=u(e,r);var o;(i.generateBuildId=await(null==e.generateBuildId?void 0:e.generateBuildId.call(e)),i.exportPathMap={},i.webpack=e.webpack&&{},null==(n=i.experimental)||null==(t=n.turbo)?void 0:t.rules)&&f(null==(o=i.experimental.turbo)?void 0:o.rules);return i.modularizeImports=i.modularizeImports?Object.fromEntries(Object.entries(i.modularizeImports).map((([e,r])=>[e,{...r,transform:"string"==typeof r.transform?r.transform:Object.entries(r.transform).map((([e,r])=>[e,r]))}]))):void 0,i.images.loaderFile&&(i.images={...e.images,loaderFile:"./"+_path.default.relative(r,e.images.loaderFile)}),JSON.stringify(i,null,2)}function f(e){for(const[n,i]of Object.entries(e))Array.isArray(i)?t(i,n):r(i,n);function r(e,n){if(e)if("loaders"in e)t(e.loaders,n);else for(const t in e){const i=e[t];"object"==typeof i&&i&&r(i,n)}}function t(e,r){for(const t of e)if("string"!=typeof t&&!(0,_util.isDeepStrictEqual)(t,JSON.parse(JSON.stringify(t))))throw Object.defineProperty(new Error(`loader ${t.loader} for match "${r}" does not have serializable options. Ensure that options passed are plain JavaScript objects and values.`),"__NEXT_ERROR_CODE",{value:"E491",enumerable:!1,configurable:!0})}}return async function(r,t){return new c(await e.projectNew(await a(r),t||{}))}}async function loadWasm(e=""){if(wasmBindings)return wasmBindings;let r=[];for(let t of["@next/swc-wasm-nodejs","@next/swc-wasm-web"])try{let r=t;e&&(r=_path.default.join(e,t,"wasm.js"));let n=await import((0,_url.pathToFileURL)(r).toString());return"@next/swc-wasm-web"===t&&(n=await n.default()),infoLog("next-swc build: wasm build @next/swc-wasm-web"),wasmBindings={css:{lightning:{transform:function(e){throw Object.defineProperty(new Error("`css.lightning.transform` is not supported by the wasm bindings."),"__NEXT_ERROR_CODE",{value:"E330",enumerable:!1,configurable:!0})},transformStyleAttr:function(e){throw Object.defineProperty(new Error("`css.lightning.transformStyleAttr` is not supported by the wasm bindings."),"__NEXT_ERROR_CODE",{value:"E324",enumerable:!1,configurable:!0})}}},isWasm:!0,transform:(e,r)=>(null==n?void 0:n.transform)?n.transform(e.toString(),r):Promise.resolve(n.transformSync(e.toString(),r)),transformSync:(e,r)=>n.transformSync(e.toString(),r),minify:(e,r)=>(null==n?void 0:n.minify)?n.minify(e.toString(),r):Promise.resolve(n.minifySync(e.toString(),r)),minifySync:(e,r)=>n.minifySync(e.toString(),r),parse:(e,r)=>(null==n?void 0:n.parse)?n.parse(e.toString(),r):Promise.resolve(n.parseSync(e.toString(),r)),getTargetTriple(){},turbo:{createProject:function(e,r){throw Object.defineProperty(new Error("`turbo.createProject` is not supported by the wasm bindings."),"__NEXT_ERROR_CODE",{value:"E403",enumerable:!1,configurable:!0})},startTurbopackTraceServer:function(e){throw Object.defineProperty(new Error("`turbo.startTurbopackTraceServer` is not supported by the wasm bindings."),"__NEXT_ERROR_CODE",{value:"E13",enumerable:!1,configurable:!0})}},mdx:{compile:(e,r)=>n.mdxCompile(e,getMdxOptions(r)),compileSync:(e,r)=>n.mdxCompileSync(e,getMdxOptions(r))}},wasmBindings}catch(n){e&&("ERR_MODULE_NOT_FOUND"===(null==n?void 0:n.code)?r.push(`Attempted to load ${t}, but it was not installed`):r.push(`Attempted to load ${t}, but an error occurred: ${n.message??n}`))}throw r}function loadNative(e){if(nativeBindings)return nativeBindings;const r=__INTERNAL_CUSTOM_TURBOPACK_BINDINGS?require(__INTERNAL_CUSTOM_TURBOPACK_BINDINGS):null;let t=r,n=[];const i=process.env.NEXT_TEST_NATIVE_DIR;for(const e of triples)if(i)try{t=require(`${i}/next-swc.${e.platformArchABI}.node`),infoLog("next-swc build: local built @next/swc from NEXT_TEST_NATIVE_DIR");break}catch(e){}else try{t=require(`@next/swc/native/next-swc.${e.platformArchABI}.node`),infoLog("next-swc build: local built @next/swc");break}catch(e){}if(!t)for(const r of triples){let i=e?_path.default.join(e,`@next/swc-${r.platformArchABI}`,`next-swc.${r.platformArchABI}.node`):`@next/swc-${r.platformArchABI}`;try{t=require(i),e||checkVersionMismatch(require(`${i}/package.json`));break}catch(e){"MODULE_NOT_FOUND"===(null==e?void 0:e.code)?n.push(`Attempted to load ${i}, but it was not installed`):n.push(`Attempted to load ${i}, but an error occurred: ${e.message??e}`),lastNativeBindingsLoadErrorCode=(null==e?void 0:e.code)??"unknown"}}if(t)return nativeBindings={isWasm:!1,transform(e,r){var n;const i=void 0!==e&&"string"!=typeof e&&!Buffer.isBuffer(e);return(null==(r=r||{})||null==(n=r.jsc)?void 0:n.parser)&&(r.jsc.parser.syntax=r.jsc.parser.syntax??"ecmascript"),t.transform(i?JSON.stringify(e):e,i,toBuffer(r))},transformSync(e,r){var n;if(void 0===e)throw Object.defineProperty(new Error("transformSync doesn't implement reading the file from filesystem"),"__NEXT_ERROR_CODE",{value:"E292",enumerable:!1,configurable:!0});if(Buffer.isBuffer(e))throw Object.defineProperty(new Error("transformSync doesn't implement taking the source code as Buffer"),"__NEXT_ERROR_CODE",{value:"E387",enumerable:!1,configurable:!0});const i="string"!=typeof e;return(null==(r=r||{})||null==(n=r.jsc)?void 0:n.parser)&&(r.jsc.parser.syntax=r.jsc.parser.syntax??"ecmascript"),t.transformSync(i?JSON.stringify(e):e,i,toBuffer(r))},minify:(e,r)=>t.minify(toBuffer(e),toBuffer(r??{})),minifySync:(e,r)=>t.minifySync(toBuffer(e),toBuffer(r??{})),parse:(e,r)=>t.parse(e,toBuffer(r??{})),getTargetTriple:t.getTargetTriple,initCustomTraceSubscriber:t.initCustomTraceSubscriber,teardownTraceSubscriber:t.teardownTraceSubscriber,turbo:{createProject:bindingToApi(r??t,!1),startTurbopackTraceServer(e){_log.warn("Turbopack trace server started. View trace at https://turbo-trace-viewer.vercel.app/"),(r??t).startTurbopackTraceServer(e)}},mdx:{compile:(e,r)=>t.mdxCompile(e,toBuffer(getMdxOptions(r))),compileSync(e,r){t.mdxCompileSync(e,toBuffer(getMdxOptions(r)))}},css:{lightning:{transform:e=>t.lightningCssTransform(e),transformStyleAttr:e=>t.lightningCssTransformStyleAttribute(e)}}},nativeBindings;throw n}function getMdxOptions(e={}){return{...e,development:e.development??!1,jsx:e.jsx??!1,mdxType:e.mdxType??"commonMark"}}function toBuffer(e){return Buffer.from(JSON.stringify(e))}async function isWasm(){return(await loadBindings()).isWasm}async function transform(e,r){return(await loadBindings()).transform(e,r)}function transformSync(e,r){return loadBindingsSync().transformSync(e,r)}async function minify(e,r){return(await loadBindings()).minify(e,r)}async function parse(e,r){let t=await loadBindings(),n=(0,_options.getParserOptions)(r);return t.parse(e,n).then((e=>JSON.parse(e)))}function getBinaryMetadata(){var e;let r;try{r=loadNative()}catch(e){}return{target:null==r||null==(e=r.getTargetTriple)?void 0:e.call(r)}}function initCustomTraceSubscriber(e){if(swcTraceFlushGuard){let r=loadNative();swcTraceFlushGuard=null==r.initCustomTraceSubscriber?void 0:r.initCustomTraceSubscriber.call(r,e)}}function once(e){let r=!1;return function(){r||(r=!0,e())}}const teardownTraceSubscriber=once((()=>{try{let e=loadNative();swcTraceFlushGuard&&(null==e.teardownTraceSubscriber||e.teardownTraceSubscriber.call(e,swcTraceFlushGuard))}catch(e){}}));