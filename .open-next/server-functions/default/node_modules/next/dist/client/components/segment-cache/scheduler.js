"use strict";function _export(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{PrefetchPriority:function(){return PrefetchPriority},bumpPrefetchTask:function(){return bumpPrefetchTask},cancelPrefetchTask:function(){return cancelPrefetchTask},pingPrefetchTask:function(){return pingPrefetchTask},schedulePrefetchTask:function(){return schedulePrefetchTask}});const _matchsegments=require("../match-segments"),_cache=require("./cache"),scheduleMicrotask="function"==typeof queueMicrotask?queueMicrotask:e=>Promise.resolve().then(e).catch((e=>setTimeout((()=>{throw e}))));var PrefetchPriority=function(e){return e[e.Intent=2]="Intent",e[e.Default=1]="Default",e[e.Background=0]="Background",e}({});const taskHeap=[],MAX_CONCURRENT_PREFETCH_REQUESTS=3;let inProgressRequests=0,sortIdCounter=0,didScheduleMicrotask=!1;function schedulePrefetchTask(e,t,n,a){const c={key:e,treeAtTimeOfPrefetch:t,priority:a,phase:1,hasBackgroundWork:!1,includeDynamicData:n,sortId:sortIdCounter++,isCanceled:!1,_heapIndex:-1};return heapPush(taskHeap,c),ensureWorkIsScheduled(),c}function cancelPrefetchTask(e){e.isCanceled=!0,heapDelete(taskHeap,e)}function bumpPrefetchTask(e,t){e.isCanceled=!1,e.sortId=sortIdCounter++,e.priority=t,-1!==e._heapIndex?heapResift(taskHeap,e):heapPush(taskHeap,e),ensureWorkIsScheduled()}function ensureWorkIsScheduled(){!didScheduleMicrotask&&hasNetworkBandwidth()&&(didScheduleMicrotask=!0,scheduleMicrotask(processQueueInMicrotask))}function hasNetworkBandwidth(){return inProgressRequests<MAX_CONCURRENT_PREFETCH_REQUESTS}function spawnPrefetchSubtask(e){return inProgressRequests++,e.then((e=>null===e?(onPrefetchConnectionClosed(),null):(e.closed.then(onPrefetchConnectionClosed),e.value)))}function onPrefetchConnectionClosed(){inProgressRequests--,ensureWorkIsScheduled()}function pingPrefetchTask(e){e.isCanceled||-1!==e._heapIndex||(heapPush(taskHeap,e),ensureWorkIsScheduled())}function processQueueInMicrotask(){didScheduleMicrotask=!1;const e=Date.now();let t=heapPeek(taskHeap);for(;null!==t&&hasNetworkBandwidth();){const n=pingRootRouteTree(e,t,(0,_cache.readOrCreateRouteCacheEntry)(e,t)),a=t.hasBackgroundWork;switch(t.hasBackgroundWork=!1,n){case 0:return;case 1:heapPop(taskHeap),t=heapPeek(taskHeap);continue;case 2:1===t.phase?(t.phase=0,heapResift(taskHeap,t)):a?(t.priority=0,heapResift(taskHeap,t)):heapPop(taskHeap),t=heapPeek(taskHeap);continue}}}function background(e){return 0===e.priority||(e.hasBackgroundWork=!0,!1)}function pingRootRouteTree(e,t,n){switch(n.status){case _cache.EntryStatus.Empty:spawnPrefetchSubtask((0,_cache.fetchRouteOnCacheMiss)(n,t)),n.staleAt=e+6e4,n.status=_cache.EntryStatus.Pending;case _cache.EntryStatus.Pending:{const e=n.blockedTasks;return null===e?n.blockedTasks=new Set([t]):e.add(t),1}case _cache.EntryStatus.Rejected:return 2;case _cache.EntryStatus.Fulfilled:{if(0!==t.phase)return 2;if(!hasNetworkBandwidth())return 0;const a=n.tree,c=t.includeDynamicData?_cache.FetchStrategy.Full:n.isPPREnabled?_cache.FetchStrategy.PPR:_cache.FetchStrategy.LoadingBoundary;switch(c){case _cache.FetchStrategy.PPR:return pingPPRRouteTree(e,t,n,a);case _cache.FetchStrategy.Full:case _cache.FetchStrategy.LoadingBoundary:{const r=new Map,s=diffRouteTreeAgainstCurrent(e,n,t.treeAtTimeOfPrefetch,a,r,c);return r.size>0&&spawnPrefetchSubtask((0,_cache.fetchSegmentPrefetchesUsingDynamicRequest)(t,n,c,s,r)),2}}break}}return 2}function pingPPRRouteTree(e,t,n,a){if(pingPerSegment(e,t,n,(0,_cache.readOrCreateSegmentCacheEntry)(e,n,a.key),t.key,a.key),null!==a.slots){if(!hasNetworkBandwidth())return 0;for(const c in a.slots){if(0===pingPPRRouteTree(e,t,n,a.slots[c]))return 0}}return 2}function diffRouteTreeAgainstCurrent(e,t,n,a,c,r){const s=n[1],o=a.slots;let u={};if(null!==o)for(const n in o){const a=o[n],i=a.segment,h=s[n],l=null==h?void 0:h[0];if(void 0!==l&&(0,_matchsegments.matchSegment)(i,l)){const s=diffRouteTreeAgainstCurrent(e,t,h,a,c,r);u[n]=s}else switch(r){case _cache.FetchStrategy.LoadingBoundary:{const r=pingPPRDisabledRouteTreeUpToLoadingBoundary(e,t,a,null,c);u[n]=r;break}case _cache.FetchStrategy.Full:{const r=pingRouteTreeAndIncludeDynamicData(e,t,a,!1,c);u[n]=r;break}}}return[a.segment,u,null,null,a.isRootLayout]}function pingPPRDisabledRouteTreeUpToLoadingBoundary(e,t,n,a,c){let r=null===a?"inside-shared-layout":null;const s=(0,_cache.readOrCreateSegmentCacheEntry)(e,t,n.key);switch(s.status){case _cache.EntryStatus.Empty:c.set(n.key,(0,_cache.upgradeToPendingSegment)(s,_cache.FetchStrategy.LoadingBoundary)),"refetch"!==a&&(r=a="refetch");break;case _cache.EntryStatus.Fulfilled:if(null!==s.loading)return(0,_cache.convertRouteTreeToFlightRouterState)(n);case _cache.EntryStatus.Pending:case _cache.EntryStatus.Rejected:}const o={};if(null!==n.slots)for(const r in n.slots){const s=n.slots[r];o[r]=pingPPRDisabledRouteTreeUpToLoadingBoundary(e,t,s,a,c)}return[n.segment,o,null,r,n.isRootLayout]}function pingRouteTreeAndIncludeDynamicData(e,t,n,a,c){const r=(0,_cache.readOrCreateSegmentCacheEntry)(e,t,n.key);let s=null;switch(r.status){case _cache.EntryStatus.Empty:s=(0,_cache.upgradeToPendingSegment)(r,_cache.FetchStrategy.Full);break;case _cache.EntryStatus.Fulfilled:r.isPartial&&(s=pingFullSegmentRevalidation(e,r,n.key));break;case _cache.EntryStatus.Pending:case _cache.EntryStatus.Rejected:r.fetchStrategy!==_cache.FetchStrategy.Full&&(s=pingFullSegmentRevalidation(e,r,n.key))}const o={};if(null!==n.slots)for(const r in n.slots){const u=n.slots[r];o[r]=pingRouteTreeAndIncludeDynamicData(e,t,u,a||null!==s,c)}null!==s&&c.set(n.key,s);const u=a||null===s?null:"refetch";return[n.segment,o,null,u,n.isRootLayout]}function pingPerSegment(e,t,n,a,c,r){switch(a.status){case _cache.EntryStatus.Empty:spawnPrefetchSubtask((0,_cache.fetchSegmentOnCacheMiss)(n,(0,_cache.upgradeToPendingSegment)(a,_cache.FetchStrategy.PPR),c,r));break;case _cache.EntryStatus.Pending:switch(a.fetchStrategy){case _cache.FetchStrategy.PPR:case _cache.FetchStrategy.Full:break;case _cache.FetchStrategy.LoadingBoundary:background(t)&&pingPPRSegmentRevalidation(e,a,n,c,r);break;default:a.fetchStrategy}break;case _cache.EntryStatus.Rejected:switch(a.fetchStrategy){case _cache.FetchStrategy.PPR:case _cache.FetchStrategy.Full:break;case _cache.FetchStrategy.LoadingBoundary:pingPPRSegmentRevalidation(e,a,n,c,r);break;default:a.fetchStrategy}case _cache.EntryStatus.Fulfilled:}}function pingPPRSegmentRevalidation(e,t,n,a,c){const r=(0,_cache.readOrCreateRevalidatingSegmentEntry)(e,t);switch(r.status){case _cache.EntryStatus.Empty:upsertSegmentOnCompletion(c,spawnPrefetchSubtask((0,_cache.fetchSegmentOnCacheMiss)(n,(0,_cache.upgradeToPendingSegment)(r,_cache.FetchStrategy.PPR),a,c)));case _cache.EntryStatus.Pending:case _cache.EntryStatus.Fulfilled:case _cache.EntryStatus.Rejected:}}function pingFullSegmentRevalidation(e,t,n){const a=(0,_cache.readOrCreateRevalidatingSegmentEntry)(e,t);if(a.status===_cache.EntryStatus.Empty){const e=(0,_cache.upgradeToPendingSegment)(a,_cache.FetchStrategy.Full);return upsertSegmentOnCompletion(n,(0,_cache.waitForSegmentCacheEntry)(e)),e}{const e=a;if(e.fetchStrategy!==_cache.FetchStrategy.Full){const t=(0,_cache.resetRevalidatingSegmentEntry)(e),a=(0,_cache.upgradeToPendingSegment)(t,_cache.FetchStrategy.Full);return upsertSegmentOnCompletion(n,(0,_cache.waitForSegmentCacheEntry)(a)),a}switch(e.status){case _cache.EntryStatus.Pending:case _cache.EntryStatus.Fulfilled:case _cache.EntryStatus.Rejected:}return null}}const noop=()=>{};function upsertSegmentOnCompletion(e,t){t.then((t=>{null!==t&&(0,_cache.upsertSegmentEntry)(Date.now(),e,t)}),noop)}function compareQueuePriority(e,t){const n=t.priority-e.priority;if(0!==n)return n;const a=t.phase-e.phase;return 0!==a?a:t.sortId-e.sortId}function heapPush(e,t){const n=e.length;e.push(t),t._heapIndex=n,heapSiftUp(e,t,n)}function heapPeek(e){return 0===e.length?null:e[0]}function heapPop(e){if(0===e.length)return null;const t=e[0];t._heapIndex=-1;const n=e.pop();return n!==t&&(e[0]=n,n._heapIndex=0,heapSiftDown(e,n,0)),t}function heapDelete(e,t){const n=t._heapIndex;if(-1!==n&&(t._heapIndex=-1,0!==e.length)){const a=e.pop();a!==t&&(e[n]=a,a._heapIndex=n,heapSiftDown(e,a,n))}}function heapResift(e,t){const n=t._heapIndex;if(-1!==n)if(0===n)heapSiftDown(e,t,0);else{compareQueuePriority(e[n-1>>>1],t)>0?heapSiftUp(e,t,n):heapSiftDown(e,t,n)}}function heapSiftUp(e,t,n){let a=n;for(;a>0;){const n=a-1>>>1,c=e[n];if(!(compareQueuePriority(c,t)>0))return;e[n]=t,t._heapIndex=n,e[a]=c,c._heapIndex=a,a=n}}function heapSiftDown(e,t,n){let a=n;const c=e.length,r=c>>>1;for(;a<r;){const n=2*(a+1)-1,r=e[n],s=n+1,o=e[s];if(compareQueuePriority(r,t)<0)s<c&&compareQueuePriority(o,r)<0?(e[a]=o,o._heapIndex=a,e[s]=t,t._heapIndex=s,a=s):(e[a]=r,r._heapIndex=a,e[n]=t,t._heapIndex=n,a=n);else{if(!(s<c&&compareQueuePriority(o,t)<0))return;e[a]=o,o._heapIndex=a,e[s]=t,t._heapIndex=s,a=s}}}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default);