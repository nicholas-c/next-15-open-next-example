"use strict";function _export(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{abortTask:function(){return abortTask},listenForDynamicRequest:function(){return listenForDynamicRequest},startPPRNavigation:function(){return startPPRNavigation},updateCacheNodeOnPopstateRestoration:function(){return updateCacheNodeOnPopstateRestoration}});const _segment=require("../../../shared/lib/segment"),_matchsegments=require("../match-segments"),_createroutercachekey=require("./create-router-cache-key"),_isnavigatingtonewrootlayout=require("./is-navigating-to-new-root-layout"),MPA_NAVIGATION_TASK={route:null,node:null,dynamicRequestTree:null,children:null};function startPPRNavigation(e,t,n,o,a,r,l){return updateCacheNodeOnNavigation(e,t,n,!1,o,a,r,[],l)}function updateCacheNodeOnNavigation(e,t,n,o,a,r,l,c,i){const s=t[1],u=n[1],d=null!==a?a[2]:null;if(!o){!0===n[4]&&(o=!0)}const f=e.parallelRoutes,h=new Map(f);let g={},p=null,R=!1,y={};for(let e in u){const t=u[e],n=s[e],a=f.get(e),v=null!==d?d[e]:null,m=t[0],N=c.concat([e,m]),T=(0,_createroutercachekey.createRouterCacheKey)(m),P=void 0!==n?n[0]:void 0,D=void 0!==a?a.get(T):void 0;let _;if(_=m===_segment.DEFAULT_SEGMENT_KEY?void 0!==n?spawnReusedTask(n):beginRenderingNewRouteTree(n,t,o,void 0!==v?v:null,r,l,N,i):void 0!==n&&void 0!==P&&(0,_matchsegments.matchSegment)(m,P)&&void 0!==D&&void 0!==n?updateCacheNodeOnNavigation(D,n,t,o,v,r,l,N,i):beginRenderingNewRouteTree(n,t,o,void 0!==v?v:null,r,l,N,i),null!==_){if(null===_.route)return MPA_NAVIGATION_TASK;null===p&&(p=new Map),p.set(e,_);const t=_.node;if(null!==t){const n=new Map(a);n.set(T,t),h.set(e,n)}const n=_.route;g[e]=n;const o=_.dynamicRequestTree;null!==o?(R=!0,y[e]=o):y[e]=n}else g[e]=t,y[e]=t}if(null===p)return null;const v={lazyData:null,rsc:e.rsc,prefetchRsc:e.prefetchRsc,head:e.head,prefetchHead:e.prefetchHead,loading:e.loading,parallelRoutes:h};return{route:patchRouterStateWithNewChildren(n,g),node:v,dynamicRequestTree:R?patchRouterStateWithNewChildren(n,y):null,children:p}}function beginRenderingNewRouteTree(e,t,n,o,a,r,l,c){return n||void 0!==e&&!(0,_isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(e,t)?createCacheNodeOnNavigation(t,o,a,r,l,c):MPA_NAVIGATION_TASK}function createCacheNodeOnNavigation(e,t,n,o,a,r){if(null===t)return spawnPendingTask(e,null,n,o,a,r);const l=e[1],c=t[4],i=0===Object.keys(l).length;if(c||o&&i)return spawnPendingTask(e,t,n,o,a,r);const s=t[2],u=new Map,d=new Map;let f={},h=!1;if(i)r.push(a);else for(let e in l){const t=l[e],c=null!==s?s[e]:null,i=t[0],g=a.concat([e,i]),p=(0,_createroutercachekey.createRouterCacheKey)(i),R=createCacheNodeOnNavigation(t,c,n,o,g,r);u.set(e,R);const y=R.dynamicRequestTree;null!==y?(h=!0,f[e]=y):f[e]=t;const v=R.node;if(null!==v){const t=new Map;t.set(p,v),d.set(e,t)}}return{route:e,node:{lazyData:null,rsc:t[1],prefetchRsc:null,head:i?n:null,prefetchHead:null,loading:t[3],parallelRoutes:d},dynamicRequestTree:h?patchRouterStateWithNewChildren(e,f):null,children:u}}function patchRouterStateWithNewChildren(e,t){const n=[e[0],t];return 2 in e&&(n[2]=e[2]),3 in e&&(n[3]=e[3]),4 in e&&(n[4]=e[4]),n}function spawnPendingTask(e,t,n,o,a,r){const l=patchRouterStateWithNewChildren(e,e[1]);l[3]="refetch";return{route:e,node:createPendingCacheNode(e,t,n,o,a,r),dynamicRequestTree:l,children:null}}function spawnReusedTask(e){return{route:e,node:null,dynamicRequestTree:null,children:null}}function listenForDynamicRequest(e,t){t.then((t=>{let{flightData:n}=t;if("string"!=typeof n){for(const t of n){const{segmentPath:n,tree:o,seedData:a,head:r}=t;a&&writeDynamicDataIntoPendingTask(e,n,o,a,r)}abortTask(e,null)}}),(t=>{abortTask(e,t)}))}function writeDynamicDataIntoPendingTask(e,t,n,o,a){let r=e;for(let e=0;e<t.length;e+=2){const n=t[e],o=t[e+1],a=r.children;if(null!==a){const e=a.get(n);if(void 0!==e){const t=e.route[0];if((0,_matchsegments.matchSegment)(o,t)){r=e;continue}}}return}finishTaskUsingDynamicDataPayload(r,n,o,a)}function finishTaskUsingDynamicDataPayload(e,t,n,o){if(null===e.dynamicRequestTree)return;const a=e.children,r=e.node;if(null===a)return void(null!==r&&(finishPendingCacheNode(r,e.route,t,n,o),e.dynamicRequestTree=null));const l=t[1],c=n[2];for(const e in t){const t=l[e],n=c[e],r=a.get(e);if(void 0!==r){const e=r.route[0];if((0,_matchsegments.matchSegment)(t[0],e)&&null!=n)return finishTaskUsingDynamicDataPayload(r,t,n,o)}}}function createPendingCacheNode(e,t,n,o,a,r){const l=e[1],c=null!==t?t[2]:null,i=new Map;for(let e in l){const t=l[e],s=null!==c?c[e]:null,u=t[0],d=a.concat([e,u]),f=(0,_createroutercachekey.createRouterCacheKey)(u),h=createPendingCacheNode(t,void 0===s?null:s,n,o,d,r),g=new Map;g.set(f,h),i.set(e,g)}const s=0===i.size;s&&r.push(a);const u=null!==t?t[1]:null,d=null!==t?t[3]:null;return{lazyData:null,parallelRoutes:i,prefetchRsc:void 0!==u?u:null,prefetchHead:s?n:[null,null],loading:void 0!==d?d:null,rsc:createDeferredRsc(),head:s?createDeferredRsc():null}}function finishPendingCacheNode(e,t,n,o,a){const r=t[1],l=n[1],c=o[2],i=e.parallelRoutes;for(let e in r){const t=r[e],n=l[e],o=c[e],s=i.get(e),u=t[0],d=(0,_createroutercachekey.createRouterCacheKey)(u),f=void 0!==s?s.get(d):void 0;void 0!==f&&(void 0!==n&&(0,_matchsegments.matchSegment)(u,n[0])&&null!=o?finishPendingCacheNode(f,t,n,o,a):abortPendingCacheNode(t,f,null))}const s=e.rsc,u=o[1];null===s?e.rsc=u:isDeferredRsc(s)&&s.resolve(u);const d=e.head;isDeferredRsc(d)&&d.resolve(a)}function abortTask(e,t){const n=e.node;if(null===n)return;const o=e.children;if(null===o)abortPendingCacheNode(e.route,n,t);else for(const e of o.values())abortTask(e,t);e.dynamicRequestTree=null}function abortPendingCacheNode(e,t,n){const o=e[1],a=t.parallelRoutes;for(let e in o){const t=o[e],r=a.get(e);if(void 0===r)continue;const l=t[0],c=(0,_createroutercachekey.createRouterCacheKey)(l),i=r.get(c);void 0!==i&&abortPendingCacheNode(t,i,n)}const r=t.rsc;isDeferredRsc(r)&&(null===n?r.resolve(null):r.reject(n));const l=t.head;isDeferredRsc(l)&&l.resolve(null)}function updateCacheNodeOnPopstateRestoration(e,t){const n=t[1],o=e.parallelRoutes,a=new Map(o);for(let e in n){const t=n[e],r=t[0],l=(0,_createroutercachekey.createRouterCacheKey)(r),c=o.get(e);if(void 0!==c){const n=c.get(l);if(void 0!==n){const o=updateCacheNodeOnPopstateRestoration(n,t),r=new Map(c);r.set(l,o),a.set(e,r)}}}const r=e.rsc,l=isDeferredRsc(r)&&"pending"===r.status;return{lazyData:null,rsc:r,head:e.head,prefetchHead:l?e.prefetchHead:[null,null],prefetchRsc:l?e.prefetchRsc:null,loading:e.loading,parallelRoutes:a}}const DEFERRED=Symbol();function isDeferredRsc(e){return e&&e.tag===DEFERRED}function createDeferredRsc(){let e,t;const n=new Promise(((n,o)=>{e=n,t=o}));return n.status="pending",n.resolve=t=>{if("pending"===n.status){const o=n;o.status="fulfilled",o.value=t,e(t)}},n.reject=e=>{if("pending"===n.status){const o=n;o.status="rejected",o.reason=e,t(e)}},n.tag=DEFERRED,n}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default);