"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"recursiveReadDir",{enumerable:!0,get:function(){return recursiveReadDir}});const _promises=_interop_require_default(require("fs/promises")),_path=_interop_require_default(require("path"));function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}async function recursiveReadDir(e,t={}){const{pathnameFilter:r,ignoreFilter:i,ignorePartFilter:s,sortPathnames:n=!0,relativePathnames:o=!0}=t,a=[],u=o?t=>t.replace(e,""):e=>e;let c=[e];for(;c.length>0;){const t=await Promise.all(c.map((async t=>{const n={directories:[],pathnames:[],links:[]};try{const e=await _promises.default.readdir(t,{withFileTypes:!0});for(const o of e){if(s&&s(o.name))continue;const e=_path.default.join(t,o.name);i&&i(e)||(o.isDirectory()?n.directories.push(e):o.isSymbolicLink()?n.links.push(e):r&&!r(e)||n.pathnames.push(u(e)))}}catch(r){if("ENOENT"!==r.code||t===e)throw r;return null}return n})));c=[];const n=[];for(const e of t)e&&(c.push(...e.directories),n.push(...e.links),a.push(...e.pathnames));if(n.length>0){const e=await Promise.all(n.map((async e=>{try{return await _promises.default.stat(e)}catch(e){if("ENOENT"!==e.code)throw e;return null}})));for(let t=0;t<n.length;t++){const i=e[t];if(!i)continue;const s=n[t];i.isDirectory()?c.push(s):r&&!r(s)||a.push(u(s))}}}return n&&a.sort(),a}