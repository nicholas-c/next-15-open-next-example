"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"recursiveDelete",{enumerable:!0,get:function(){return recursiveDelete}});const _fs=require("fs"),_path=require("path"),_iserror=_interop_require_default(require("./is-error")),_wait=require("./wait");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}const unlinkPath=async(e,t=!1,r=1)=>{try{t?await _fs.promises.rmdir(e):await _fs.promises.unlink(e)}catch(i){const a=(0,_iserror.default)(i)&&i.code;if(("EBUSY"===a||"ENOTEMPTY"===a||"EPERM"===a||"EMFILE"===a)&&r<3)return await(0,_wait.wait)(100*r),unlinkPath(e,t,r++);if("ENOENT"===a)return;throw i}};async function recursiveDelete(e,t,r=""){let i;try{i=await _fs.promises.readdir(e,{withFileTypes:!0})}catch(e){if((0,_iserror.default)(e)&&"ENOENT"===e.code)return;throw e}await Promise.all(i.map((async i=>{const a=(0,_path.join)(e,i.name);let s=i.isDirectory();const n=i.isSymbolicLink();if(n){const e=await _fs.promises.readlink(a);try{s=(await _fs.promises.stat((0,_path.isAbsolute)(e)?e:(0,_path.join)((0,_path.dirname)(a),e))).isDirectory()}catch{}}const o=(0,_path.join)(r,i.name);if(!t||!t.test(o))return s&&await recursiveDelete(a,t,o),unlinkPath(a,!n&&s)})))}