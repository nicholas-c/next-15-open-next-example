(()=>{"use strict";var t={448:function(t,e,o){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};const n=o(361),s=r(o(937)),i=r(o(457)),c=s.default("agent-base");function u(t){return Boolean(t)&&"function"==typeof t.addRequest}function a(){const{stack:t}=new Error;return"string"==typeof t&&t.split("\n").some((t=>-1!==t.indexOf("(https.js:")||-1!==t.indexOf("node:https:")))}function l(t,e){return new l.Agent(t,e)}!function(t){class e extends n.EventEmitter{constructor(t,e){super();let o=e;"function"==typeof t?this.callback=t:t&&(o=t),this.timeout=null,o&&"number"==typeof o.timeout&&(this.timeout=o.timeout),this.maxFreeSockets=1,this.maxSockets=1,this.maxTotalSockets=1/0,this.sockets={},this.freeSockets={},this.requests={},this.options={}}get defaultPort(){return"number"==typeof this.explicitDefaultPort?this.explicitDefaultPort:a()?443:80}set defaultPort(t){this.explicitDefaultPort=t}get protocol(){return"string"==typeof this.explicitProtocol?this.explicitProtocol:a()?"https:":"http:"}set protocol(t){this.explicitProtocol=t}callback(t,e,o){throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`')}addRequest(t,e){const o=Object.assign({},e);"boolean"!=typeof o.secureEndpoint&&(o.secureEndpoint=a()),null==o.host&&(o.host="localhost"),null==o.port&&(o.port=o.secureEndpoint?443:80),null==o.protocol&&(o.protocol=o.secureEndpoint?"https:":"http:"),o.host&&o.path&&delete o.path,delete o.agent,delete o.hostname,delete o._defaultAgent,delete o.defaultPort,delete o.createConnection,t._last=!0,t.shouldKeepAlive=!1;let r=!1,n=null;const s=o.timeout||this.timeout,l=e=>{t._hadError||(t.emit("error",e),t._hadError=!0)},f=()=>{n=null,r=!0;const t=new Error(`A "socket" was not created for HTTP request before ${s}ms`);t.code="ETIMEOUT",l(t)},p=t=>{r||(null!==n&&(clearTimeout(n),n=null),l(t))},d=e=>{if(r)return;if(null!=n&&(clearTimeout(n),n=null),u(e))return c("Callback returned another Agent instance %o",e.constructor.name),void e.addRequest(t,o);if(e)return e.once("free",(()=>{this.freeSocket(e,o)})),void t.onSocket(e);const s=new Error(`no Duplex stream was returned to agent-base for \`${t.method} ${t.path}\``);l(s)};if("function"==typeof this.callback){this.promisifiedCallback||(this.callback.length>=3?(c("Converting legacy callback function to promise"),this.promisifiedCallback=i.default(this.callback)):this.promisifiedCallback=this.callback),"number"==typeof s&&s>0&&(n=setTimeout(f,s)),"port"in o&&"number"!=typeof o.port&&(o.port=Number(o.port));try{c("Resolving socket for %o request: %o",o.protocol,`${t.method} ${t.path}`),Promise.resolve(this.promisifiedCallback(t,o)).then(d,p)}catch(t){Promise.reject(t).catch(p)}}else l(new Error("`callback` is not defined"))}freeSocket(t,e){c("Freeing socket %o %o",t.constructor.name,e),t.destroy()}destroy(){c("Destroying agent %o",this.constructor.name)}}t.Agent=e,t.prototype=t.Agent.prototype}(l||(l={})),t.exports=l},457:(t,e)=>{function o(t){return function(e,o){return new Promise(((r,n)=>{t.call(this,e,o,((t,e)=>{t?n(t):r(e)}))}))}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=o},44:function(t,e,o){var r=this&&this.__awaiter||function(t,e,o,r){function n(t){return t instanceof o?t:new o((function(e){e(t)}))}return new(o||(o=Promise))((function(o,s){function i(t){try{u(r.next(t))}catch(t){s(t)}}function c(t){try{u(r.throw(t))}catch(t){s(t)}}function u(t){t.done?o(t.value):n(t.value).then(i,c)}u((r=r.apply(t,e||[])).next())}))},n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const s=n(o(808)),i=n(o(404)),c=n(o(310)),u=n(o(491)),a=n(o(937)),l=o(448),f=n(o(357)),p=a.default("https-proxy-agent:agent");class d extends l.Agent{constructor(t){let e;if(e="string"==typeof t?c.default.parse(t):t,!e)throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");p("creating new HttpsProxyAgent instance: %o",e),super(e);const o=Object.assign({},e);this.secureProxy=e.secureProxy||y(o.protocol),o.host=o.hostname||o.host,"string"==typeof o.port&&(o.port=parseInt(o.port,10)),!o.port&&o.host&&(o.port=this.secureProxy?443:80),this.secureProxy&&!("ALPNProtocols"in o)&&(o.ALPNProtocols=["http 1.1"]),o.host&&o.path&&(delete o.path,delete o.pathname),this.proxy=o}callback(t,e){return r(this,void 0,void 0,(function*(){const{proxy:o,secureProxy:r}=this;let n;r?(p("Creating `tls.Socket`: %o",o),n=i.default.connect(o)):(p("Creating `net.Socket`: %o",o),n=s.default.connect(o));const c=Object.assign({},o.headers);let a=`CONNECT ${`${e.host}:${e.port}`} HTTP/1.1\r\n`;o.auth&&(c["Proxy-Authorization"]=`Basic ${Buffer.from(o.auth).toString("base64")}`);let{host:l,port:d,secureEndpoint:y}=e;m(d,y)||(l+=`:${d}`),c.Host=l,c.Connection="close";for(const t of Object.keys(c))a+=`${t}: ${c[t]}\r\n`;const b=f.default(n);n.write(`${a}\r\n`);const{statusCode:g,buffered:v}=yield b;if(200===g){if(t.once("socket",h),e.secureEndpoint){p("Upgrading socket connection to TLS");const t=e.servername||e.host;return i.default.connect(Object.assign(Object.assign({},x(e,"host","hostname","path","port")),{socket:n,servername:t}))}return n}n.destroy();const k=new s.default.Socket({writable:!1});return k.readable=!0,t.once("socket",(t=>{p("replaying proxy buffer for failed request"),u.default(t.listenerCount("data")>0),t.push(v),t.push(null)})),k}))}}function h(t){t.resume()}function m(t,e){return Boolean(!e&&80===t||e&&443===t)}function y(t){return"string"==typeof t&&/^https:?$/i.test(t)}function x(t,...e){const o={};let r;for(r in t)e.includes(r)||(o[r]=t[r]);return o}e.default=d},157:function(t,e,o){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};const n=r(o(44));function s(t){return new n.default(t)}!function(t){t.HttpsProxyAgent=n.default,t.prototype=n.default.prototype}(s||(s={})),t.exports=s},357:function(t,e,o){var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=r(o(937)).default("https-proxy-agent:parse-proxy-response");function s(t){return new Promise(((e,o)=>{let r=0;const s=[];function i(){const e=t.read();e?f(e):t.once("readable",i)}function c(){t.removeListener("end",a),t.removeListener("error",l),t.removeListener("close",u),t.removeListener("readable",i)}function u(t){n("onclose had error %o",t)}function a(){n("onend")}function l(t){c(),n("onerror %o",t),o(t)}function f(t){s.push(t),r+=t.length;const o=Buffer.concat(s,r);if(-1===o.indexOf("\r\n\r\n"))return n("have not received end of HTTP headers yet..."),void i();const c=o.toString("ascii",0,o.indexOf("\r\n")),u=+c.split(" ")[1];n("got proxy server response: %o",c),e({statusCode:u,buffered:o})}t.on("error",l),t.on("close",u),t.on("end",a),i()}))}e.default=s},491:t=>{t.exports=require("assert")},361:t=>{t.exports=require("events")},808:t=>{t.exports=require("net")},937:t=>{t.exports=require("next/dist/compiled/debug")},404:t=>{t.exports=require("tls")},310:t=>{t.exports=require("url")}},e={};function o(r){var n=e[r];if(void 0!==n)return n.exports;var s=e[r]={exports:{}},i=!0;try{t[r].call(s.exports,s,s.exports,o),i=!1}finally{i&&delete e[r]}return s.exports}void 0!==o&&(o.ab=__dirname+"/");var r=o(157);module.exports=r})();