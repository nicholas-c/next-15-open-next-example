"use strict";function _export(e,r){for(var t in r)Object.defineProperty(e,t,{enumerable:!0,get:r[t]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{ReactServerPrerenderResult:function(){return ReactServerPrerenderResult},ReactServerResult:function(){return ReactServerResult},ServerPrerenderStreamResult:function(){return ServerPrerenderStreamResult},createReactServerPrerenderResult:function(){return createReactServerPrerenderResult},createReactServerPrerenderResultFromRender:function(){return createReactServerPrerenderResultFromRender},prerenderAndAbortInSequentialTasks:function(){return prerenderAndAbortInSequentialTasks},prerenderClientWithPhases:function(){return prerenderClientWithPhases},prerenderServerWithPhases:function(){return prerenderServerWithPhases}});const _invarianterror=require("../../shared/lib/invariant-error"),_dynamicrendering=require("./dynamic-rendering");function prerenderAndAbortInSequentialTasks(e,r){if("edge"===process.env.NEXT_RUNTIME)throw Object.defineProperty(new _invarianterror.InvariantError("`prerenderAndAbortInSequentialTasks` should not be called in edge runtime."),"__NEXT_ERROR_CODE",{value:"E538",enumerable:!1,configurable:!0});return new Promise(((t,n)=>{let s;setImmediate((()=>{try{s=e(),s.catch((()=>{}))}catch(e){n(e)}})),setImmediate((()=>{r(),t(s)}))}))}function prerenderServerWithPhases(e,r,...t){if("edge"===process.env.NEXT_RUNTIME)throw Object.defineProperty(new _invarianterror.InvariantError("`prerenderAndAbortInSequentialTasks` should not be called in edge runtime."),"__NEXT_ERROR_CODE",{value:"E538",enumerable:!1,configurable:!0});return new Promise(((n,s)=>{let a;function u(){try{a&&(a.markComplete(),this()),n(a)}catch(e){s(e)}}function i(){try{a&&(a.markPhase(),this())}catch(e){s(e)}}e.addEventListener("abort",(()=>{(0,_dynamicrendering.isPrerenderInterruptedError)(e.reason)?a.markInterrupted():a.markComplete()}),{once:!0}),setImmediate((()=>{try{a=new ServerPrerenderStreamResult(r())}catch(e){s(e)}}));let o=0;for(;o<t.length-1;o++){const e=t[o];setImmediate(i.bind(e))}if(t[o]){const e=t[o];setImmediate(u.bind(e))}}))}const PENDING=0,COMPLETE=1,INTERRUPTED=2,ERRORED=3;class ServerPrerenderStreamResult{constructor(e){this.status=PENDING,this.reason=null,this.trailingChunks=[],this.currentChunks=[],this.chunksByPhase=[this.currentChunks];const r=e.getReader(),t=({done:e,value:s})=>{e?this.status===PENDING&&(this.status=COMPLETE):(this.status===PENDING||this.status===INTERRUPTED?this.currentChunks.push(s):this.trailingChunks.push(s),r.read().then(t,n))},n=e=>{this.status=ERRORED,this.reason=e};r.read().then(t,n)}markPhase(){this.currentChunks=[],this.chunksByPhase.push(this.currentChunks)}markComplete(){this.status===PENDING&&(this.status=COMPLETE)}markInterrupted(){this.status=INTERRUPTED}asPhasedStream(){switch(this.status){case COMPLETE:case INTERRUPTED:return new PhasedStream(this.chunksByPhase);default:throw Object.defineProperty(new _invarianterror.InvariantError(`ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`),"__NEXT_ERROR_CODE",{value:"E612",enumerable:!1,configurable:!0})}}asStream(){switch(this.status){case COMPLETE:case INTERRUPTED:const e=this.chunksByPhase,r=this.trailingChunks;return new ReadableStream({start(t){for(let r=0;r<e.length;r++){const n=e[r];for(let e=0;e<n.length;e++)t.enqueue(n[e])}for(let e=0;e<r.length;e++)t.enqueue(r[e]);t.close()}});default:throw Object.defineProperty(new _invarianterror.InvariantError(`ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`),"__NEXT_ERROR_CODE",{value:"E612",enumerable:!1,configurable:!0})}}}class PhasedStream extends ReadableStream{constructor(e){if(0===e.length)throw Object.defineProperty(new _invarianterror.InvariantError("PhasedStream expected at least one phase but none were found."),"__NEXT_ERROR_CODE",{value:"E574",enumerable:!1,configurable:!0});let r;super({start(e){r=e}}),this.destination=r,this.nextPhase=0,this.chunksByPhase=e,this.releasePhase()}releasePhase(){if(!(this.nextPhase<this.chunksByPhase.length))throw Object.defineProperty(new _invarianterror.InvariantError("PhasedStream expected more phases to release but none were found."),"__NEXT_ERROR_CODE",{value:"E541",enumerable:!1,configurable:!0});{const e=this.chunksByPhase[this.nextPhase++];for(let r=0;r<e.length;r++)this.destination.enqueue(e[r])}}assertExhausted(){if(this.nextPhase<this.chunksByPhase.length)throw Object.defineProperty(new _invarianterror.InvariantError("PhasedStream expected no more phases to release but some were found."),"__NEXT_ERROR_CODE",{value:"E584",enumerable:!1,configurable:!0})}}function prerenderClientWithPhases(e,...r){if("edge"===process.env.NEXT_RUNTIME)throw Object.defineProperty(new _invarianterror.InvariantError("`prerenderAndAbortInSequentialTasks` should not be called in edge runtime."),"__NEXT_ERROR_CODE",{value:"E538",enumerable:!1,configurable:!0});return new Promise(((t,n)=>{let s;function a(){try{this(),t(s)}catch(e){n(e)}}function u(){try{this()}catch(e){n(e)}}setImmediate((()=>{try{s=e(),s.catch((e=>n(e)))}catch(e){n(e)}}));let i=0;for(;i<r.length-1;i++){const e=r[i];setImmediate(u.bind(e))}if(r[i]){const e=r[i];setImmediate(a.bind(e))}}))}class ReactServerResult{constructor(e){this._stream=e}tee(){if(null===this._stream)throw Object.defineProperty(new Error("Cannot tee a ReactServerResult that has already been consumed"),"__NEXT_ERROR_CODE",{value:"E106",enumerable:!1,configurable:!0});const e=this._stream.tee();return this._stream=e[0],e[1]}consume(){if(null===this._stream)throw Object.defineProperty(new Error("Cannot consume a ReactServerResult that has already been consumed"),"__NEXT_ERROR_CODE",{value:"E470",enumerable:!1,configurable:!0});const e=this._stream;return this._stream=null,e}}async function createReactServerPrerenderResult(e){const r=[],{prelude:t}=await e,n=t.getReader();for(;;){const{done:e,value:t}=await n.read();if(e)return new ReactServerPrerenderResult(r);r.push(t)}}async function createReactServerPrerenderResultFromRender(e){const r=[],t=e.getReader();for(;;){const{done:e,value:n}=await t.read();if(e)break;r.push(n)}return new ReactServerPrerenderResult(r)}class ReactServerPrerenderResult{assertChunks(e){if(null===this._chunks)throw Object.defineProperty(new _invarianterror.InvariantError(`Cannot \`${e}\` on a ReactServerPrerenderResult that has already been consumed.`),"__NEXT_ERROR_CODE",{value:"E593",enumerable:!1,configurable:!0});return this._chunks}consumeChunks(e){const r=this.assertChunks(e);return this.consume(),r}consume(){this._chunks=null}constructor(e){this._chunks=e}asUnclosingStream(){return createUnclosingStream(this.assertChunks("asUnclosingStream()"))}consumeAsUnclosingStream(){return createUnclosingStream(this.consumeChunks("consumeAsUnclosingStream()"))}asStream(){return createClosingStream(this.assertChunks("asStream()"))}consumeAsStream(){return createClosingStream(this.consumeChunks("consumeAsStream()"))}}function createUnclosingStream(e){let r=0;return new ReadableStream({async pull(t){r<e.length&&t.enqueue(e[r++])}})}function createClosingStream(e){let r=0;return new ReadableStream({async pull(t){r<e.length?t.enqueue(e[r++]):t.close()}})}