"use strict";function _export(t,r){for(var e in r)Object.defineProperty(t,e,{enumerable:!0,get:r[e]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{AwaiterMulti:function(){return AwaiterMulti},AwaiterOnce:function(){return AwaiterOnce}});const _invarianterror=require("../../shared/lib/invariant-error");class AwaiterMulti{constructor({onError:t}={}){this.promises=new Set,this.waitUntil=t=>{const r=()=>{this.promises.delete(t)};t.then(r,(t=>{r(),this.onError(t)})),this.promises.add(t)},this.onError=t??console.error}async awaiting(){for(;this.promises.size>0;){const t=Array.from(this.promises);this.promises.clear(),await Promise.allSettled(t)}}}class AwaiterOnce{constructor(t={}){this.done=!1,this.waitUntil=t=>{if(this.done)throw Object.defineProperty(new _invarianterror.InvariantError("Cannot call waitUntil() on an AwaiterOnce that was already awaited"),"__NEXT_ERROR_CODE",{value:"E563",enumerable:!1,configurable:!0});return this.awaiter.waitUntil(t)},this.awaiter=new AwaiterMulti(t)}async awaiting(){return this.pending||(this.pending=this.awaiter.awaiting().finally((()=>{this.done=!0}))),this.pending}}