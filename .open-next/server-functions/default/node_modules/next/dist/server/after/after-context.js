"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"AfterContext",{enumerable:!0,get:function(){return AfterContext}});const _pqueue=_interop_require_default(require("next/dist/compiled/p-queue")),_invarianterror=require("../../shared/lib/invariant-error"),_isthenable=require("../../shared/lib/is-thenable"),_workasyncstorageexternal=require("../app-render/work-async-storage.external"),_revalidationutils=require("./revalidation-utils"),_asynclocalstorage=require("../app-render/async-local-storage"),_workunitasyncstorageexternal=require("../app-render/work-unit-async-storage.external"),_aftertaskasyncstorageexternal=require("../app-render/after-task-async-storage.external");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}class AfterContext{constructor({waitUntil:e,onClose:r,onTaskError:t}){this.workUnitStores=new Set,this.waitUntil=e,this.onClose=r,this.onTaskError=t,this.callbackQueue=new _pqueue.default,this.callbackQueue.pause()}after(e){if((0,_isthenable.isThenable)(e))this.waitUntil||errorWaitUntilNotAvailable(),this.waitUntil(e.catch((e=>this.reportTaskError("promise",e))));else{if("function"!=typeof e)throw Object.defineProperty(new Error("`after()`: Argument must be a promise or a function"),"__NEXT_ERROR_CODE",{value:"E50",enumerable:!1,configurable:!0});this.addCallback(e)}}addCallback(e){this.waitUntil||errorWaitUntilNotAvailable();const r=_workunitasyncstorageexternal.workUnitAsyncStorage.getStore();r&&this.workUnitStores.add(r);const t=_aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore(),a=t?t.rootTaskSpawnPhase:null==r?void 0:r.phase;this.runCallbacksOnClosePromise||(this.runCallbacksOnClosePromise=this.runCallbacksOnClose(),this.waitUntil(this.runCallbacksOnClosePromise));const n=(0,_asynclocalstorage.bindSnapshot)((async()=>{try{await _aftertaskasyncstorageexternal.afterTaskAsyncStorage.run({rootTaskSpawnPhase:a},(()=>e()))}catch(e){this.reportTaskError("function",e)}}));this.callbackQueue.add(n)}async runCallbacksOnClose(){return await new Promise((e=>this.onClose(e))),this.runCallbacks()}async runCallbacks(){if(0===this.callbackQueue.size)return;for(const e of this.workUnitStores)e.phase="after";const e=_workasyncstorageexternal.workAsyncStorage.getStore();if(!e)throw Object.defineProperty(new _invarianterror.InvariantError("Missing workStore in AfterContext.runCallbacks"),"__NEXT_ERROR_CODE",{value:"E547",enumerable:!1,configurable:!0});return(0,_revalidationutils.withExecuteRevalidates)(e,(()=>(this.callbackQueue.start(),this.callbackQueue.onIdle())))}reportTaskError(e,r){if(console.error("promise"===e?"A promise passed to `after()` rejected:":"An error occurred in a function passed to `after()`:",r),this.onTaskError)try{null==this.onTaskError||this.onTaskError.call(this,r)}catch(e){console.error(Object.defineProperty(new _invarianterror.InvariantError("`onTaskError` threw while handling an error thrown from an `after` task",{cause:e}),"__NEXT_ERROR_CODE",{value:"E569",enumerable:!1,configurable:!0}))}}}function errorWaitUntilNotAvailable(){throw Object.defineProperty(new Error("`after()` will not work correctly, because `waitUntil` is not available in the current environment."),"__NEXT_ERROR_CODE",{value:"E91",enumerable:!1,configurable:!0})}