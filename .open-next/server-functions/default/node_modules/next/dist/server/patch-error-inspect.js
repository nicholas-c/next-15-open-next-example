"use strict";function _export(e,r){for(var t in r)Object.defineProperty(e,t,{enumerable:!0,get:r[t]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{patchErrorInspectEdgeLite:function(){return patchErrorInspectEdgeLite},patchErrorInspectNodeJS:function(){return patchErrorInspectNodeJS},setBundlerFindSourceMapImplementation:function(){return setBundlerFindSourceMapImplementation}});const _module=require("module"),_path=_interop_require_wildcard(require("path")),_url=_interop_require_wildcard(require("url")),_sourcemap=require("next/dist/compiled/source-map"),_middlewarewebpack=require("../client/components/react-dev-overlay/server/middleware-webpack"),_shared=require("../client/components/react-dev-overlay/server/shared"),_workunitasyncstorageexternal=require("./app-render/work-unit-async-storage.external"),_picocolors=require("../lib/picocolors");function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interop_require_wildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var c=o?Object.getOwnPropertyDescriptor(e,a):null;c&&(c.get||c.set)?Object.defineProperty(n,a,c):n[a]=e[a]}return n.default=e,t&&t.set(e,n),n}let bundlerFindSourceMapPayload=()=>{};function setBundlerFindSourceMapImplementation(e){bundlerFindSourceMapPayload=e}function frameToString(e){let r,t=null!==e.lineNumber?`:${e.lineNumber}`:"";return null!==e.column&&""!==t&&(t+=`:${e.column}`),r=null!==e.file&&e.file.startsWith("file://")&&URL.canParse(e.file)?_path.relative(process.cwd(),_url.fileURLToPath(e.file)):null!==e.file&&e.file.startsWith("/")?_path.relative(process.cwd(),e.file):e.file,e.methodName?`    at ${e.methodName} (${r}${t})`:`    at ${r}${t}`}function computeErrorName(e){return e.name||"Error"}function prepareUnsourcemappedStackTrace(e,r){let t=computeErrorName(e)+": "+(e.message||"");for(let e=0;e<r.length;e++)t+="\n    at "+r[e].toString();return t}function shouldIgnoreListGeneratedFrame(e){return e.startsWith("node:")||e.includes("node_modules")}function shouldIgnoreListOriginalFrame(e){return e.includes("node_modules")}function findApplicableSourceMapPayload(e,r){if("sections"in r){const t=e.lineNumber??0,n=e.column??0;let o=r.sections[0];for(let e=0;e<r.sections.length&&r.sections[e].offset.line<=t&&r.sections[e].offset.column<=n;e++)o=r.sections[e];return void 0===o?void 0:o.map}return r}function createUnsourcemappedFrame(e){return{stack:{arguments:e.arguments,column:e.column,file:e.file,lineNumber:e.lineNumber,methodName:e.methodName,ignored:shouldIgnoreListGeneratedFrame(e.file)},code:null}}function getSourcemappedFrameIfPossible(e,r,t){var n,o;const a=r.get(e.file);let c,i;if(void 0===a){let t,n=e.file;n.startsWith("/")&&(n=_url.pathToFileURL(e.file).toString());try{const e=(0,_module.findSourceMap)(n);t=null==e?void 0:e.payload}catch(r){return console.error(`${n}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${r}`),createUnsourcemappedFrame(e)}if(void 0===t&&(t=bundlerFindSourceMapPayload(n)),void 0===t)return createUnsourcemappedFrame(e);i=t;try{c=new _sourcemap.SourceMapConsumer(i)}catch(r){return console.error(`${n}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${r}`),createUnsourcemappedFrame(e)}r.set(e.file,{map:c,payload:i})}else c=a.map,i=a.payload;const l=c.originalPositionFor({column:e.column??0,line:e.lineNumber??1});if(null===l.source)return{stack:{arguments:e.arguments,column:e.column,file:e.file,lineNumber:e.lineNumber,methodName:e.methodName,ignored:shouldIgnoreListGeneratedFrame(e.file)},code:null};const u=c.sourceContentFor(l.source,!0)??null,s=findApplicableSourceMapPayload(e,i);let d=!1;if(void 0===s)console.error("No applicable source map found in sections for frame",e);else if(shouldIgnoreListOriginalFrame(l.source))d=!0;else{var p;const e=s.sources.indexOf(l.source);d=(null==(p=s.ignoreList)?void 0:p.includes(e))??!1}const m={methodName:null==(o=e.methodName)||null==(n=o.replace("__WEBPACK_DEFAULT_EXPORT__","default"))?void 0:n.replace("__webpack_exports__.",""),column:l.column,file:l.source,lineNumber:l.line,arguments:[],ignored:d};return{stack:m,code:"production"!==process.env.NODE_ENV?(0,_shared.getOriginalCodeFrame)(m,u,t.colors):null}}function parseAndSourceMap(e,r){const t=!1;let n=String(e.stack);const o=computeErrorName(e);let a=n.indexOf("react-stack-bottom-frame");-1!==a&&(a=n.lastIndexOf("\n",a)),-1===a||t||(n=n.slice(0,a));const c=(0,_middlewarewebpack.parseStack)(n),i=new Map;let l="",u=null;for(const e of c)if(null===e.file)l+="\n"+frameToString(e);else{const n=getSourcemappedFrameIfPossible(e,i,r);"production"===process.env.NODE_ENV||null===n.code||null!==u||n.stack.ignored||(u=n.code),n.stack.ignored?t&&!r.colors?l+="\n"+frameToString(n.stack):t&&(l+="\n"+(0,_picocolors.dim)(frameToString(n.stack))):l+="\n"+frameToString(n.stack)}return o+": "+e.message+l+(null!==u?"\n"+u:"")}function sourceMapError(e,r){const t=void 0!==e.cause?Object.defineProperty(new Error(e.message,{cause:e.cause}),"__NEXT_ERROR_CODE",{value:"E394",enumerable:!1,configurable:!0}):Object.defineProperty(new Error(e.message),"__NEXT_ERROR_CODE",{value:"E394",enumerable:!1,configurable:!0});t.stack=parseAndSourceMap(e,r);for(const r in e)Object.prototype.hasOwnProperty.call(t,r)||(t[r]=e[r]);return t}function patchErrorInspectNodeJS(e){const r=Symbol.for("nodejs.util.inspect.custom");e.prepareStackTrace=prepareUnsourcemappedStackTrace,e.prototype[r]=function(e,t,n){return _workunitasyncstorageexternal.workUnitAsyncStorage.exit((()=>{const o=sourceMapError(this,t),a=o[r];Object.defineProperty(o,r,{value:void 0,enumerable:!1,writable:!0});try{return n(o,{...t,depth:(t.depth??2)-e})}finally{o[r]=a}}))}}function patchErrorInspectEdgeLite(e){const r=Symbol.for("edge-runtime.inspect.custom");e.prepareStackTrace=prepareUnsourcemappedStackTrace,e.prototype[r]=function({format:e}){return _workunitasyncstorageexternal.workUnitAsyncStorage.exit((()=>{const t=sourceMapError(this,{}),n=t[r];Object.defineProperty(t,r,{value:void 0,enumerable:!1,writable:!0});try{return e(t)}finally{t[r]=n}}))}}