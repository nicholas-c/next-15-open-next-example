"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"default",{enumerable:!0,get:function(){return _default}});const _lrucache=require("../lru-cache"),_tagsmanifestexternal=require("../incremental-cache/tags-manifest.external"),memoryCache=new _lrucache.LRUCache(52428800,(e=>e.size)),pendingSets=new Map,DefaultCacheHandler={async get(e,t){await pendingSets.get(e);const a=memoryCache.get(e);if(!a)return;const r=a.entry;if(performance.timeOrigin+performance.now()>r.timestamp+1e3*r.revalidate)return;if((0,_tagsmanifestexternal.isTagStale)(r.tags,r.timestamp)||(0,_tagsmanifestexternal.isTagStale)(t,r.timestamp))return;const[n,s]=r.value.tee();return r.value=s,{...r,value:n}},async set(e,t){let a=()=>{};const r=new Promise((e=>{a=e}));pendingSets.set(e,r);const n=await t;let s=0;try{const[t,a]=n.value.tee();n.value=t;const r=a.getReader();for(let e;!(e=await r.read()).done;)s+=Buffer.from(e.value).byteLength;memoryCache.set(e,{entry:n,isErrored:!1,errorRetryCount:0,size:s})}catch{}finally{a(),pendingSets.delete(e)}},async expireTags(...e){for(const t of e)_tagsmanifestexternal.tagsManifest.items[t]||(_tagsmanifestexternal.tagsManifest.items[t]={}),_tagsmanifestexternal.tagsManifest.items[t].revalidatedAt=Date.now()},async receiveExpiredTags(...e){return this.expireTags(...e)}},_default=DefaultCacheHandler;