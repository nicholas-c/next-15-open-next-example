"use strict";function _export(e,t){for(var a in t)Object.defineProperty(e,a,{enumerable:!0,get:t[a]})}Object.defineProperty(exports,"__esModule",{value:!0}),_export(exports,{CacheHandler:function(){return CacheHandler},IncrementalCache:function(){return IncrementalCache}});const _responsecache=require("../../response-cache"),_filesystemcache=_interop_require_default(require("./file-system-cache")),_normalizepagepath=require("../../../shared/lib/page-path/normalize-page-path"),_constants=require("../../../lib/constants"),_toroute=require("../to-route"),_sharedrevalidatetimings=require("./shared-revalidate-timings"),_workunitasyncstorageinstance=require("../../app-render/work-unit-async-storage-instance"),_workunitasyncstorageexternal=require("../../app-render/work-unit-async-storage.external"),_handlers=require("../../use-cache/handlers");function _interop_require_default(e){return e&&e.__esModule?e:{default:e}}class CacheHandler{constructor(e){}async get(...e){return{}}async set(...e){}async revalidateTag(...e){}resetRequestCache(){}}class IncrementalCache{constructor({fs:e,dev:t,flushToDisk:a,minimalMode:r,serverDistDir:n,requestHeaders:s,requestProtocol:i,maxMemoryCacheSize:o,getPrerenderManifest:c,fetchCacheKeyPrefix:l,CurCacheHandler:d,allowedRevalidateHeaderKeys:h}){var u,f,p,_;this.locks=new Map;const y=!!process.env.NEXT_PRIVATE_DEBUG_CACHE;this.hasCustomCacheHandler=Boolean(d);const g=Symbol.for("@next/cache-handlers"),v=globalThis;if(d)y&&console.log("using custom cache handler",d.name);else{const t=v[g];(null==t?void 0:t.FetchCache)?d=t.FetchCache:e&&n&&(y&&console.log("using filesystem cache handler"),d=_filesystemcache.default)}process.env.__NEXT_TEST_MAX_ISR_CACHE&&(o=parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE,10)),this.dev=t,this.disableForTestmode="true"===process.env.NEXT_PRIVATE_TEST_PROXY;this["minimalMode"]=r,this.requestHeaders=s,this.requestProtocol=i,this.allowedRevalidateHeaderKeys=h,this.prerenderManifest=c(),this.revalidateTimings=new _sharedrevalidatetimings.SharedRevalidateTimings(this.prerenderManifest),this.fetchCacheKeyPrefix=l;let m=[];s[_constants.PRERENDER_REVALIDATE_HEADER]===(null==(f=this.prerenderManifest)||null==(u=f.preview)?void 0:u.previewModeId)&&(this.isOnDemandRevalidate=!0),r&&"string"==typeof s[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER]&&s[_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER]===(null==(_=this.prerenderManifest)||null==(p=_.preview)?void 0:p.previewModeId)&&(m=s[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(",")),d&&(this.cacheHandler=new d({dev:t,fs:e,flushToDisk:a,serverDistDir:n,revalidatedTags:m,maxMemoryCacheSize:o,_requestHeaders:s,fetchCacheKeyPrefix:l}))}calculateRevalidate(e,t,a,r){if(a)return Math.floor(performance.timeOrigin+performance.now()-1e3);const n=this.revalidateTimings.get((0,_toroute.toRoute)(e))??(!r&&1);return"number"==typeof n?1e3*n+t:n}_getPathname(e,t){return t?e:(0,_normalizepagepath.normalizePagePath)(e)}resetRequestCache(){var e,t;null==(t=this.cacheHandler)||null==(e=t.resetRequestCache)||e.call(t)}async lock(e){let t=()=>Promise.resolve();const a=this.locks.get(e);a&&await a;const r=new Promise((a=>{t=async()=>{a(),this.locks.delete(e)}}));return this.locks.set(e,r),t}async revalidateTag(e){var t;const a=[];(null==(t=this.cacheHandler)?void 0:t.revalidateTag)&&a.push(this.cacheHandler.revalidateTag(e));const r=(0,_handlers.getCacheHandlers)();if(r){e=Array.isArray(e)?e:[e];for(const t of r)a.push(t.expireTags(...e))}await Promise.all(a)}async generateCacheKey(e,t={}){const a="v3",r=[],n=new TextEncoder,s=new TextDecoder;if(t.body)if("function"==typeof t.body.getReader){const c=t.body,l=[];try{await c.pipeTo(new WritableStream({write(e){"string"==typeof e?(l.push(n.encode(e)),r.push(e)):(l.push(e),r.push(s.decode(e,{stream:!0})))}})),r.push(s.decode());const d=l.reduce(((e,t)=>e+t.length),0),h=new Uint8Array(d);let u=0;for(const f of l)h.set(f,u),u+=f.length;t._ogBody=h}catch(p){console.error("Problem reading body",p)}}else if("function"==typeof t.body.keys){const _=t.body;t._ogBody=t.body;for(const y of new Set([..._.keys()])){const g=_.getAll(y);r.push(`${y}=${(await Promise.all(g.map((async e=>"string"==typeof e?e:await e.text())))).join(",")}`)}}else if("function"==typeof t.body.arrayBuffer){const v=t.body,m=await v.arrayBuffer();r.push(await v.text()),t._ogBody=new Blob([m],{type:v.type})}else"string"==typeof t.body&&(r.push(t.body),t._ogBody=t.body);const i="function"==typeof(t.headers||{}).keys?Object.fromEntries(t.headers):Object.assign({},t.headers);"traceparent"in i&&delete i.traceparent,"tracestate"in i&&delete i.tracestate;const o=JSON.stringify([a,this.fetchCacheKeyPrefix||"",e,t.method,i,t.mode,t.redirect,t.credentials,t.referrer,t.referrerPolicy,t.integrity,t.cache,r]);if("edge"===process.env.NEXT_RUNTIME){function C(e){return Array.prototype.map.call(new Uint8Array(e),(e=>e.toString(16).padStart(2,"0"))).join("")}const E=n.encode(o);return C(await crypto.subtle.digest("SHA-256",E))}return require("crypto").createHash("sha256").update(o).digest("hex")}async get(e,t){var a,r;if(t.kind===_responsecache.IncrementalCacheKind.FETCH){const t=_workunitasyncstorageinstance.workUnitAsyncStorageInstance.getStore(),a=t?(0,_workunitasyncstorageexternal.getRenderResumeDataCache)(t):null;if(a){const t=a.fetch.get(e);if((null==t?void 0:t.kind)===_responsecache.CachedRouteKind.FETCH)return{isStale:!1,value:t,revalidateAfter:!1,isFallback:!1}}}if(this.disableForTestmode||this.dev&&(t.kind!==_responsecache.IncrementalCacheKind.FETCH||"no-cache"===this.requestHeaders["cache-control"]))return null;const{isFallback:n}=t;e=this._getPathname(e,t.kind===_responsecache.IncrementalCacheKind.FETCH);let s=null,i=t.revalidate;const o=await(null==(a=this.cacheHandler)?void 0:a.get(e,t));if((null==o||null==(r=o.value)?void 0:r.kind)===_responsecache.CachedRouteKind.FETCH){if([...t.tags||[],...t.softTags||[]].some((e=>{var t;return null==(t=this.revalidatedTags)?void 0:t.includes(e)})))return null;i=i||o.value.revalidate;const e=(performance.timeOrigin+performance.now()-(o.lastModified||0))/1e3>i,a=o.value.data;return{isStale:e,value:{kind:_responsecache.CachedRouteKind.FETCH,data:a,revalidate:i},revalidateAfter:performance.timeOrigin+performance.now()+1e3*i,isFallback:n}}const c=this.revalidateTimings.get((0,_toroute.toRoute)(e));let l,d;return-1===(null==o?void 0:o.lastModified)?(l=-1,d=-1*_constants.CACHE_ONE_YEAR):(d=this.calculateRevalidate(e,(null==o?void 0:o.lastModified)||performance.timeOrigin+performance.now(),!!this.dev&&t.kind!==_responsecache.IncrementalCacheKind.FETCH,t.isFallback),l=!1!==d&&d<performance.timeOrigin+performance.now()||void 0),o&&(s={isStale:l,curRevalidate:c,revalidateAfter:d,value:o.value,isFallback:n}),!o&&this.prerenderManifest.notFoundRoutes.includes(e)&&(s={isStale:l,value:null,curRevalidate:c,revalidateAfter:d,isFallback:n},this.set(e,s.value,t)),s}async set(e,t,a){if((null==t?void 0:t.kind)===_responsecache.CachedRouteKind.FETCH){const a=_workunitasyncstorageinstance.workUnitAsyncStorageInstance.getStore(),r=a?(0,_workunitasyncstorageexternal.getPrerenderResumeDataCache)(a):null;r&&r.fetch.set(e,t)}if(this.disableForTestmode||this.dev&&!a.fetchCache)return;e=this._getPathname(e,a.fetchCache);const r=JSON.stringify(t).length;if(a.fetchCache&&!this.hasCustomCacheHandler&&r>2097152){if(this.dev)throw Object.defineProperty(new Error(`Failed to set Next.js data cache, items over 2MB can not be cached (${r} bytes)`),"__NEXT_ERROR_CODE",{value:"E86",enumerable:!1,configurable:!0})}else try{var n;void 0===a.revalidate||a.fetchCache||this.revalidateTimings.set((0,_toroute.toRoute)(e),a.revalidate),await(null==(n=this.cacheHandler)?void 0:n.set(e,t,a))}catch(t){console.warn("Failed to update prerender cache for",e,t)}}}