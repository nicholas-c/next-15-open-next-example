"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"DefaultRouteMatcherManager",{enumerable:!0,get:function(){return DefaultRouteMatcherManager}});const _utils=require("../../shared/lib/router/utils"),_localeroutematcher=require("../route-matchers/locale-route-matcher"),_ensureleadingslash=require("../../shared/lib/page-path/ensure-leading-slash"),_detachedpromise=require("../../lib/detached-promise");class DefaultRouteMatcherManager{get compilationID(){return this.providers.length}async waitTillReady(){this.waitTillReadyPromise&&(await this.waitTillReadyPromise,delete this.waitTillReadyPromise)}async reload(){const{promise:e,resolve:t,reject:i}=new _detachedpromise.DetachedPromise;this.waitTillReadyPromise=e;const a=this.compilationID;try{const e=[],t=await Promise.all(this.providers.map((e=>e.matchers()))),i=new Map,r={};for(const a of t)for(const t of a){t.duplicated&&delete t.duplicated;const a=i.get(t.definition.pathname);if(a){const e=r[t.definition.pathname]??[a];e.push(t),r[t.definition.pathname]=e,a.duplicated=e,t.duplicated=e}e.push(t),i.set(t.definition.pathname,t)}if(this.matchers.duplicates=r,this.previousMatchers.length===e.length&&this.previousMatchers.every(((t,i)=>t===e[i])))return;this.previousMatchers=e,this.matchers.static=e.filter((e=>!e.isDynamic));const s=e.filter((e=>e.isDynamic)),n=new Map,o=new Array;for(let e=0;e<s.length;e++){const t=s[e].definition.pathname,i=n.get(t)??[];i.push(e),1===i.length&&(n.set(t,i),o.push(t))}const l=(0,_utils.getSortedRoutes)(o),c=[];for(const e of l){const t=n.get(e);if(!Array.isArray(t))throw Object.defineProperty(new Error("Invariant: expected to find identity in indexes map"),"__NEXT_ERROR_CODE",{value:"E271",enumerable:!1,configurable:!0});const i=t.map((e=>s[e]));c.push(...i)}if(this.matchers.dynamic=c,this.compilationID!==a)throw Object.defineProperty(new Error("Invariant: expected compilation to finish before new matchers were added, possible missing await"),"__NEXT_ERROR_CODE",{value:"E242",enumerable:!1,configurable:!0})}catch(e){i(e)}finally{this.lastCompilationID=a,t()}}push(e){this.providers.push(e)}async test(e,t){return null!==await this.match(e,t)}async match(e,t){for await(const i of this.matchAll(e,t))return i;return null}validate(e,t,i){var a;return t instanceof _localeroutematcher.LocaleRouteMatcher?t.match(e,i):(null==(a=i.i18n)?void 0:a.inferredFromDefault)?t.match(i.i18n.pathname):t.match(e)}async*matchAll(e,t){if(this.lastCompilationID!==this.compilationID)throw Object.defineProperty(new Error("Invariant: expected routes to have been loaded before match"),"__NEXT_ERROR_CODE",{value:"E235",enumerable:!1,configurable:!0});if(e=(0,_ensureleadingslash.ensureLeadingSlash)(e),!(0,_utils.isDynamicRoute)(e))for(const i of this.matchers.static){const a=this.validate(e,i,t);a&&(yield a)}if(null==t?void 0:t.skipDynamic)return null;for(const i of this.matchers.dynamic){const a=this.validate(e,i,t);a&&(yield a)}return null}constructor(){this.providers=[],this.matchers={static:[],dynamic:[],duplicates:{}},this.lastCompilationID=this.compilationID,this.previousMatchers=[]}}