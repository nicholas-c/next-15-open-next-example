"use strict";function murmurhash2(t){let e=0;for(let r=0;r<t.length;r++){const s=t.charCodeAt(r);e=Math.imul(e^s,1540483477),e^=e>>>13,e=Math.imul(e,1540483477)}return e>>>0}Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"BloomFilter",{enumerable:!0,get:function(){return BloomFilter}});const DEFAULT_ERROR_RATE=1e-4;class BloomFilter{static from(t,e){void 0===e&&(e=DEFAULT_ERROR_RATE);const r=new BloomFilter(t.length,e);for(const e of t)r.add(e);return r}export(){const t={numItems:this.numItems,errorRate:this.errorRate,numBits:this.numBits,numHashes:this.numHashes,bitArray:this.bitArray};if("nodejs"===process.env.NEXT_RUNTIME&&this.errorRate<DEFAULT_ERROR_RATE){const e=JSON.stringify(t),r=require("next/dist/compiled/gzip-size").sync(e);r>1024&&console.warn("Creating filter with error rate less than 0.1% (0.001) can increase the size dramatically proceed with caution. Received error rate "+this.errorRate+" resulted in size "+e.length+" bytes, "+r+" bytes (gzip)")}return t}import(t){this.numItems=t.numItems,this.errorRate=t.errorRate,this.numBits=t.numBits,this.numHashes=t.numHashes,this.bitArray=t.bitArray}add(t){this.getHashValues(t).forEach((t=>{this.bitArray[t]=1}))}contains(t){return this.getHashValues(t).every((t=>this.bitArray[t]))}getHashValues(t){const e=[];for(let r=1;r<=this.numHashes;r++){const s=murmurhash2(""+t+r)%this.numBits;e.push(s)}return e}constructor(t,e=DEFAULT_ERROR_RATE){this.numItems=t,this.errorRate=e,this.numBits=Math.ceil(-t*Math.log(e)/(Math.log(2)*Math.log(2))),this.numHashes=Math.ceil(this.numBits/t*Math.log(2)),this.bitArray=new Array(this.numBits).fill(0)}}