"use strict";const childProcess=require("child_process"),{isLinux:isLinux,getReport:getReport}=require("./process"),{LDD_PATH:LDD_PATH,readFile:readFile,readFileSync:readFileSync}=require("./filesystem");let cachedFamilyFilesystem,cachedVersionFilesystem;const command="getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";let commandOut="";const safeCommand=()=>commandOut||new Promise((e=>{childProcess.exec(command,((i,s)=>{commandOut=i?" ":s,e(commandOut)}))})),safeCommandSync=()=>{if(!commandOut)try{commandOut=childProcess.execSync(command,{encoding:"utf8"})}catch(e){commandOut=" "}return commandOut},GLIBC="glibc",RE_GLIBC_VERSION=/LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,MUSL="musl",isFileMusl=e=>e.includes("libc.musl-")||e.includes("ld-musl-"),familyFromReport=()=>{const e=getReport();return e.header&&e.header.glibcVersionRuntime?GLIBC:Array.isArray(e.sharedObjects)&&e.sharedObjects.some(isFileMusl)?MUSL:null},familyFromCommand=e=>{const[i,s]=e.split(/[\r\n]+/);return i&&i.includes(GLIBC)?GLIBC:s&&s.includes(MUSL)?MUSL:null},getFamilyFromLddContent=e=>e.includes("musl")?MUSL:e.includes("GNU C Library")?GLIBC:null,familyFromFilesystem=async()=>{if(void 0!==cachedFamilyFilesystem)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{const e=await readFile(LDD_PATH);cachedFamilyFilesystem=getFamilyFromLddContent(e)}catch(e){}return cachedFamilyFilesystem},familyFromFilesystemSync=()=>{if(void 0!==cachedFamilyFilesystem)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{const e=readFileSync(LDD_PATH);cachedFamilyFilesystem=getFamilyFromLddContent(e)}catch(e){}return cachedFamilyFilesystem},family=async()=>{let e=null;if(isLinux()&&(e=await familyFromFilesystem(),e||(e=familyFromReport()),!e)){const i=await safeCommand();e=familyFromCommand(i)}return e},familySync=()=>{let e=null;if(isLinux()&&(e=familyFromFilesystemSync(),e||(e=familyFromReport()),!e)){const i=safeCommandSync();e=familyFromCommand(i)}return e},isNonGlibcLinux=async()=>isLinux()&&await family()!==GLIBC,isNonGlibcLinuxSync=()=>isLinux()&&familySync()!==GLIBC,versionFromFilesystem=async()=>{if(void 0!==cachedVersionFilesystem)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{const e=(await readFile(LDD_PATH)).match(RE_GLIBC_VERSION);e&&(cachedVersionFilesystem=e[1])}catch(e){}return cachedVersionFilesystem},versionFromFilesystemSync=()=>{if(void 0!==cachedVersionFilesystem)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{const e=readFileSync(LDD_PATH).match(RE_GLIBC_VERSION);e&&(cachedVersionFilesystem=e[1])}catch(e){}return cachedVersionFilesystem},versionFromReport=()=>{const e=getReport();return e.header&&e.header.glibcVersionRuntime?e.header.glibcVersionRuntime:null},versionSuffix=e=>e.trim().split(/\s+/)[1],versionFromCommand=e=>{const[i,s,n]=e.split(/[\r\n]+/);return i&&i.includes(GLIBC)?versionSuffix(i):s&&n&&s.includes(MUSL)?versionSuffix(n):null},version=async()=>{let e=null;if(isLinux()&&(e=await versionFromFilesystem(),e||(e=versionFromReport()),!e)){const i=await safeCommand();e=versionFromCommand(i)}return e},versionSync=()=>{let e=null;if(isLinux()&&(e=versionFromFilesystemSync(),e||(e=versionFromReport()),!e)){const i=safeCommandSync();e=versionFromCommand(i)}return e};module.exports={GLIBC:GLIBC,MUSL:MUSL,family:family,familySync:familySync,isNonGlibcLinux:isNonGlibcLinux,isNonGlibcLinuxSync:isNonGlibcLinuxSync,version:version,versionSync:versionSync};